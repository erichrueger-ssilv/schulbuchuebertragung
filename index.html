<!doctype html>
<html lang="de">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>OCR zu E-Buch</title>

    <!-- PWA Setup -->
    <link rel="manifest" href="manifest.json" />
    <meta name="theme-color" content="#1a1a1e" />
    <link rel="apple-touch-icon" href="icon-192.png" />
    <link rel="icon" type="image/png" href="favicon-ssilv.png" />

    <!-- Lokale Bibliotheken -->
    <link rel="stylesheet" href="libs/katex/katex.min.css" />
    <script src="libs/katex/katex.min.js"></script>
    <script src="libs/katex/contrib/auto-render.min.js"></script>
    <script src="libs/marked/marked.min.js"></script>
    <script src="libs/pdfjs/pdf.min.js"></script>
    <script src="libs/html-docx/html-docx.min.js"></script>

    <style>
        /* --- Grundlegende Stile & Variablen (Dark Mode Default) --- */
        :root {
            --bg-color: #1a1a1e;
            --text-color: #fff;
            --primary-color: #da4353;
            --primary-hover: #dc1e35;
            --secondary-color: #2a2a30;
            --border-color: #444;
            --input-bg: #2c2c33;
            --input-text: #fff;
            --log-bg: #111;
            --success-color: #da4353;
            --preview-bg: #2c2c33;
            --preview-text: #e0e0e0;
            --preview-code-bg: #111;
            --preview-table-border: #444;
            --preview-th-bg: #383840;

            --font-family:
                -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
                Helvetica, Arial, sans-serif;
            --focus-ring: 2px solid var(--primary-color);
        }

        /* --- Light Mode Override --- */
        html.light-theme {
            --bg-color: #f5f5f7;
            --text-color: #333333;
            --primary-color: #da4353;
            --primary-hover: #dc1e35;
            --secondary-color: #ffffff;
            --border-color: #cccccc;
            --input-bg: #ffffff;
            --input-text: #333;
            --log-bg: #e0e0e0;
            --success-color: #da4353;
            --error-color: #da4353;
            --preview-bg: #ffffff;
            --preview-text: #000000;
            --preview-code-bg: #f0f0f0;
            --preview-table-border: #ccc;
            --preview-th-bg: #f0f0f0;
        }

        html,
        body {
            height: 100vh;
            width: 100vw;
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--text-color);
            font-size: 14px;
            transition:
                background-color 0.3s,
                color 0.3s;
        }

        /* --- Layout-Struktur --- */
        .container {
            display: grid;
            grid-template-columns: 380px 1fr;
            height: 100vh;
            gap: 10px;
            padding: 10px;
            box-sizing: border-box;
        }

        .main-content {
            display: grid;
            grid-template-rows: auto 1fr auto auto;
            gap: 10px;
            height: 100%;
            box-sizing: border-box;
            overflow: hidden;
        }

        .preview-area {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            height: 100%;
            overflow: hidden;
        }

        /* --- Steuerungs-Panel (linke Spalte) --- */
        .controls {
            background-color: var(--secondary-color);
            border-radius: 8px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            position: relative;
        }

        .header-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 10px;
            padding-bottom: 10px;
        }

        /* Logo Styles */
        .header-logo {
            height: 32px;
            margin-right: 10px;
            width: auto;
            cursor: pointer;
        }

        .header-logo:hover {
            opacity: 0.8;
        }

        .title-group {
            display: flex;
            align-items: center;
        }

        .controls h1 {
            margin: 0;
            font-size: 1.2em;
            color: var(--primary-color);
        }

        .header-actions {
            display: flex;
            gap: 8px;
        }

        /* Header Buttons */
        .header-btn {
            background-color: var(--border-color);
            border: 1px solid var(--border-color);
            color: var(--text-color);
            cursor: pointer;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 1.1em;
            line-height: 1;
            transition:
                background-color 0.2s,
                color 0.2s;
        }

        .header-btn:hover {
            background-color: var(--primary-hover);
            border-color: var(--primary-hover);
            color: white;
        }

        /* Input Row with Camera Button */
        .input-row-combined {
            display: flex;
            gap: 5px;
            align-items: stretch;
        }

        #camera-btn {
            flex-shrink: 0;
            width: 50px;
            font-size: 1.5em;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: var(--border-color);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            transition:
                background-color 0.2s,
                color 0.2s;
            cursor: pointer;
        }

        #camera-btn:hover {
            background-color: var(--primary-hover);
            border-color: var(--primary-hover);
            color: white;
        }

        .file-name-text {
            margin-top: 5px;
            font-size: 0.9em;
            color: var(--text-color);
            font-style: italic;
            word-break: break-all;
            display: none;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-group label {
            font-weight: 600;
            font-size: 1em;
        }

        .control-group.horizontal {
            flex-direction: row;
            align-items: center;
            gap: 10px;
            justify-content: space-between;
        }

        .control-group.horizontal label {
            flex-shrink: 1;
            padding-right: 5px;
        }

        /* --- UNIFIED BUTTON STYLES & LAYOUT --- */

        /* Quick Settings Layout */
        .quick-settings-controls {
            display: grid;
            grid-template-columns: 1fr auto auto;
            gap: 5px;
        }

        .quick-settings-controls button {
            padding: 8px 12px;
            font-weight: bold;
            font-size: 0.95em;
        }

        /* Action Buttons Layout */
        .action-buttons {
            display: grid;
            grid-template-columns: 2fr 1fr 1fr;
            gap: 5px;
            margin-top: 10px;
        }

        button#toggle-processing-btn {
            width: 100%;
            font-size: 1.1em;
            white-space: nowrap;
        }

        /* Buttons beim Stoppen trotzdem rot lassen */
        button#toggle-processing-btn.stop-mode {
            background-color: var(--error-color) !important;
            border-color: var(--error-color) !important;
        }

        button#toggle-processing-btn.stop-mode:hover:not(:disabled) {
            background-color: #dc1e35 !important;
        }

        button#download-md-btn,
        button#download-docx-btn {
            padding: 5px;
            font-size: 0.9em;
            white-space: nowrap;
        }

        /* VEREINHEITLICHUNG DER BUTTON STYLES */
        #toggle-processing-btn:not(.stop-mode),
        #download-md-btn,
        #download-docx-btn,
        #add-profile-btn,
        #del-profile-btn,
        #analyze-toc-btn {
            background-color: var(--border-color);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            transition:
                background-color 0.2s,
                color 0.2s;
        }

        #toggle-processing-btn:not(.stop-mode):hover:not(:disabled),
        #download-md-btn:hover:not(:disabled),
        #download-docx-btn:hover:not(:disabled),
        #add-profile-btn:hover:not(:disabled),
        #del-profile-btn:hover:not(:disabled),
        #analyze-toc-btn:hover:not(:disabled) {
            background-color: var(--primary-hover);
            border-color: var(--primary-hover);
            color: white;
            filter: none;
            cursor: pointer;
        }

        #add-profile-btn:active,
        #del-profile-btn:active {
            background-color: var(--primary-color);
        }

        .model-selection-group {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 8px;
            align-items: center;
        }

        #fetch-models-btn {
            grid-column: 1 / 2;
            padding: 8px 12px;
            font-size: 0.9em;
            background-color: var(--secondary-color);
            color: var(--text-color);
            border: 1px solid var(--border-color);
        }

        #fetch-models-btn:hover:not(:disabled) {
            background-color: var(--input-bg);
        }

        #model-name {
            grid-column: 2 / 2;
        }

        #numbering-options {
            margin-top: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        /* --- Formularelemente & Buttons --- */
        input[type="text"],
        input[type="password"],
        input[type="number"],
        textarea,
        select {
            width: 100%;
            background-color: var(--input-bg);
            color: var(--input-text);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 8px;
            font-size: 1em;
            box-sizing: border-box;
        }

        input:focus,
        textarea:focus,
        select:focus,
        button:focus,
        summary:focus,
        .header-btn:focus,
        .log-area:focus,
        #rendered-preview:focus,
        #img-nav-input:focus {
            outline: var(--focus-ring);
            outline-offset: 2px;
        }

        input[type="file"] {
            color: transparent;
        }

        input[type="file"]::file-selector-button {
            background-color: var(--border-color);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            transition:
                background-color 0.2s,
                color 0.2s;
            font-family: var(--font-family);
            font-size: 0.95em;
            font-weight: bold;
            margin-right: 5px;
        }

        input[type="file"]::file-selector-button:hover {
            background-color: var(--primary-hover);
            border-color: var(--primary-hover);
            color: white;
        }

        textarea {
            resize: vertical;
            min-height: 150px;
            font-family: "Courier New", Courier, monospace;
        }

        textarea#manual-prompt {
            min-height: auto;
            height: auto;
            resize: vertical;
            font-family: var(--font-family);
            white-space: pre-wrap;
            overflow-y: auto;
        }

        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            transition: background-color 0.2s;
        }

        button:hover:not(:disabled) {
            background-color: var(--primary-hover);
        }

        button:disabled,
        button[disabled],
        input[type="file"]::file-selector-button:disabled {
            background-color: #555 !important;
            color: #aaa !important;
            border: 1px solid #444 !important;
            cursor: not-allowed !important;
            opacity: 0.8 !important;
        }

        /* Progress Bar Styles */
        .progress-wrapper {
            margin-top: 0;
            padding: 10px;
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            display: none;
        }

        .progress-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        .progress-container {
            width: 100%;
            background-color: var(--border-color);
            border-radius: 10px;
            height: 10px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            width: 0%;
            background-color: var(--primary-color);
            transition: width 0.3s ease;
        }

        /* Styles f√ºr Config Buttons */
        .config-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
        }

        .config-buttons button {
            background-color: var(--secondary-color);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            font-size: 0.9em;
            padding: 6px 10px;
        }

        .config-buttons button:hover {
            background-color: var(--border-color);
        }

        /* --- Details/Summary (Akkordeon) --- */
        details {
            background: rgba(128, 128, 128, 0.05);
            border: 1px solid var(--border-color);
            border-radius: 4px;
        }

        summary {
            font-weight: 600;
            cursor: pointer;
            padding: 8px;
            list-style: none;
        }

        summary::-webkit-details-marker {
            display: none;
        }

        summary::after {
            content: "+";
            float: right;
            font-weight: bold;
        }

        details[open]>summary::after {
            content: "-";
        }

        .details-content {
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            border-top: 1px solid var(--border-color);
        }

        details details {
            margin-left: 5px;
            margin-right: 5px;
            margin-bottom: 5px;
            border-left: 3px solid var(--border-color);
        }

        /* --- Switch-Toggle Komponente --- */
        .switch {
            position: relative;
            display: inline-block;
            width: 34px;
            height: 20px;
            flex-shrink: 0;
        }

        .switch input {
            opacity: 0;
            width: 100%;
            height: 100%;
            position: absolute;
            cursor: pointer;
            z-index: 2;
            margin: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #555;
            transition: 0.4s;
            border-radius: 20px;
            z-index: 1;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 14px;
            width: 14px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.4s;
            border-radius: 50%;
        }

        input:checked+.slider {
            background-color: var(--primary-color);
        }

        input:checked+.slider:before {
            transform: translateX(14px);
        }

        input:focus-visible+.slider {
            outline: 2px solid var(--primary-color);
            outline-offset: 2px;
            box-shadow: 0 0 5px var(--text-color);
        }

        /* Disclaimer Style */
        .ai-disclaimer {
            font-size: 0.85em;
            color: var(--error-color);
            margin-top: 10px;
            padding: 8px;
            background: rgba(218, 67, 83, 0.1);
            border-radius: 4px;
            border: 1px solid var(--error-color);
        }

        /* --- Hauptinhalt (Vorschau & Log) --- */
        .preview-controls {
            display: flex;
            gap: 10px;
            padding: 10px;
            background-color: var(--secondary-color);
            border-radius: 8px;
            border: 1px solid var(--border-color);
            align-items: center;
        }

        .preview-controls button {
            background-color: var(--border-color);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            font-size: 0.95em;
            transition:
                background-color 0.2s,
                color 0.2s;
        }

        .preview-controls button:hover:not(.active) {
            background-color: var(--primary-hover);
            border-color: var(--primary-hover);
            color: white;
            cursor: pointer;
        }

        .preview-controls button.active {
            background-color: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        .preview-controls button.active:hover {
            background-color: var(--primary-hover);
        }

        #tts-btn:hover:not(.speaking) {
            background-color: var(--primary-hover);
            border-color: var(--primary-hover);
            color: white;
        }

        #tts-btn.speaking {
            background-color: var(--error-color);
            color: white;
            border-color: var(--error-color);
        }

        #tts-btn.speaking:hover {
            filter: brightness(0.9);
            background-color: var(--error-color);
        }

        .preview-panel {
            background-color: var(--secondary-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: auto;
            padding: 15px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }

        .preview-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
            margin-bottom: 10px;
            min-height: 35px;
        }

        .preview-panel-header h3 {
            margin: 0;
            font-size: 1em;
        }

        .preview-panel-header button {
            font-size: 0.9em;
            padding: 4px 8px;
            background-color: var(--border-color);
            border: 1px solid var(--border-color);
            color: var(--text-color);
            transition:
                background-color 0.2s,
                color 0.2s;
            cursor: pointer;
        }

        .preview-panel-header button:hover {
            background-color: var(--primary-hover);
            border-color: var(--primary-hover);
            color: white;
        }

        .img-nav-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .img-nav-controls button {
            padding: 2px 8px;
            font-size: 0.95em;
            background-color: var(--border-color);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            line-height: 1;
            cursor: pointer;
            transition:
                background-color 0.2s,
                color 0.2s;
        }

        .img-nav-controls button:hover {
            background-color: var(--primary-hover);
            border-color: var(--primary-hover);
            color: white;
        }

        /* NEUER STYLE F√úR DAS NAVIGATION INPUT */
        #img-nav-input {
            width: 50px;
            text-align: center;
            padding: 2px 5px;
            background-color: var(--input-bg);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            /* Remove spinners for Chrome/Safari/Edge/Opera */
            -moz-appearance: textfield;
        }

        #img-nav-input::-webkit-outer-spin-button,
        #img-nav-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        #image-preview {
            max-width: 100%;
            height: auto;
            border: 1px solid var(--border-color);
            background-color: #fff;
            display: block;
        }

        #raw-preview {
            width: 100%;
            height: 100%;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-family: "Courier New", Courier, monospace;
            font-size: 0.9em;
            line-height: 1.5;
            color: var(--text-color);
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            padding: 8px;
            box-sizing: border-box;
            resize: none;
        }

        #rendered-preview {
            color: var(--preview-text);
            background-color: var(--preview-bg);
            padding: 10px;
            border-radius: 4px;
            height: 100%;
            overflow-y: auto;
        }

        #rendered-preview table,
        #rendered-preview th,
        #rendered-preview td {
            border: 1px solid var(--preview-table-border);
            border-collapse: collapse;
            padding: 8px;
            color: var(--preview-text);
        }

        #rendered-preview th {
            background-color: var(--preview-th-bg);
        }

        #rendered-preview img {
            max-width: 100%;
        }

        #rendered-preview code {
            background-color: var(--preview-code-bg);
            color: var(--preview-text);
            padding: 2px 4px;
            border-radius: 3px;
        }

        #rendered-preview pre {
            background-color: var(--preview-code-bg);
            color: var(--preview-text);
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
        }

        .log-area {
            background-color: var(--log-bg);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 10px;
            height: 150px;
            overflow-y: scroll;
            font-family: "Courier New", Courier, monospace;
            font-size: 1em;
            white-space: pre-wrap;
            box-sizing: border-box;
        }

        #pdf-canvas {
            display: none;
        }

        /* --- MODAL DIALOG STYLES --- */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(2px);
        }

        .modal-content {
            background-color: var(--secondary-color);
            border: 1px solid var(--border-color);
            padding: 20px;
            border-radius: 8px;
            width: 350px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            gap: 15px;
            color: var(--text-color);
        }

        .modal-content.large {
            width: 90%;
            max-width: 600px;
            height: 80vh;
        }

        .modal-content h3 {
            margin: 0;
            color: var(--primary-color);
        }

        .modal-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            flex-wrap: wrap;
        }

        .modal-buttons button {
            padding: 8px 15px;
        }

        .modal-buttons .btn-cancel {
            background-color: var(--error-color);
        }

        .modal-buttons .btn-cancel:hover {
            background-color: #a02a37;
        }

        /* Shortcut List Styles */
        .shortcut-list {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 8px;
            font-size: 0.9em;
            margin-top: 10px;
        }

        .shortcut-key {
            font-weight: bold;
            background: var(--input-bg);
            padding: 2px 6px;
            border-radius: 4px;
            text-align: center;
            border: 1px solid var(--border-color);
        }

        #camera-stream {
            width: 100%;
            height: 100%;
            object-fit: contain;
            background: #000;
            border-radius: 4px;
        }

        #camera-status {
            font-size: 0.9em;
            text-align: center;
        }

        .file-status-indicator {
            padding: 5px;
            background: var(--input-bg);
            border: 1px solid var(--primary-color);
            color: var(--primary-color);
            border-radius: 4px;
            margin-top: 5px;
            font-size: 0.9em;
            display: none;
            align-items: center;
            justify-content: space-between;
        }

        .file-status-indicator button {
            background: transparent;
            color: var(--text-color);
            padding: 2px 5px;
            font-size: 1.2em;
        }

        #camera-batch-counter {
            background: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
            position: absolute;
            top: 20px;
            left: 20px;
            font-weight: bold;
            display: none;
        }

        #manual-prompt-container input {
            border: 1px solid var(--border-color);
            background-color: var(--input-bg);
            color: var(--text-color);
        }

        #manual-prompt-container input:focus {
            box-shadow: 0 0 5px rgba(0, 123, 255, 0.5);
        }

        @media (max-width: 768px) {

            html,
            body {
                overflow: auto;
                height: auto;
            }

            .container {
                grid-template-columns: 1fr;
                height: auto;
                padding: 5px;
            }

            .controls {
                overflow-y: visible;
            }

            .preview-area {
                grid-template-columns: 1fr;
                height: auto;
            }

            .preview-panel {
                min-height: 300px;
            }

            .log-area {
                height: 200px;
            }
        }

        /* Vision Mode Styles */
        #vision-response-area::-webkit-scrollbar {
            width: 8px;
        }

        #vision-response-area::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        #vision-ui-container input:disabled,
        #vision-ui-container button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Animation f√ºr wartenden Text */
        .vision-loading {
            animation: pulse 1.5s infinite;
            color: var(--primary-color);
        }

        @keyframes pulse {
            0% {
                opacity: 0.5;
            }

            50% {
                opacity: 1;
            }

            100% {
                opacity: 0.5;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <!-- Linke Spalte: Steuerung -->
        <div class="controls">
            <div class="header-row">
                <div class="title-group">
                    <img src="logo-ssilv.png" alt="Logo (Klicken f√ºr Shortcuts)" class="header-logo"
                        title="Klicken f√ºr Shortcuts Liste" onerror="this.style.display = 'none'" />
                    <h1>OCR zu E-Buch</h1>
                </div>
                <div class="header-actions">
                    <button id="theme-toggle" class="header-btn" aria-label="Design umschalten (Hell/Dunkel)"
                        accesskey="l" title="Design umschalten (Alt + l)">
                        <span aria-hidden="true">‚òÄÔ∏è</span>
                    </button>
                </div>
            </div>

            <!-- Combined Input Row: Camera + Files -->
            <div class="control-group">
                <div class="input-row-combined">
                    <button id="camera-btn" aria-label="Kamera √∂ffnen (Shortcut: k)" title="Foto aufnehmen (Alt + k)"
                        accesskey="k">
                        üì∑
                    </button>
                    <input type="file" id="file-input" multiple accept=".pdf, .png, .jpg, .jpeg, .bmp, .webp, .tiff"
                        accesskey="d" title="Alt + d" />
                </div>
                <div id="file-name-display" class="file-name-text"></div>
                <div id="camera-file-status" class="file-status-indicator">
                    <span id="camera-status-text">üì∑ 0 Foto(s) im Stapel</span>
                    <button id="clear-camera-btn" title="Aufnahmen verwerfen">
                        √ó
                    </button>
                </div>
            </div>

            <!-- Manueller Prompt Bereich (UPDATED: Textarea) -->
            <div class="control-group" id="manual-prompt-container">
                <label for="manual-prompt">Manueller Prompt (f√ºr das aktuelle Bild)</label>
                <textarea id="manual-prompt" placeholder="Prompt eingeben und Enter dr√ºcken oder Start..." accesskey="m"
                    title="Alt + m" rows="3"></textarea>
            </div>

            <!-- Action Buttons kombiniert -->
            <div class="action-buttons">
                <!-- Start/Stop kombiniert -->
                <button id="toggle-processing-btn" accesskey="s" title="Alt + s">
                    ‚ñ∂ Start
                </button>

                <!-- Download MD kombiniert -->
                <button id="download-md-btn" disabled accesskey="h" title="Alt + h">
                    ‚¨á .md
                </button>

                <button id="download-docx-btn" disabled accesskey="w" title="Alt + w">
                    ‚¨á .docx
                </button>
            </div>

            <!-- Schnell-Einstellungen -->
            <div class="control-group" style="margin-top: 15px">
                <label for="quick-settings-select">Schnell-Einstellungen</label>
                <div class="quick-settings-controls">
                    <select id="quick-settings-select" aria-label="Gespeichertes Profil w√§hlen" accesskey="q"
                        title="Alt + q">
                        <option value="Standard">Standard</option>
                    </select>
                    <button id="add-profile-btn" title="Aktuelle Einstellungen als neues Profil speichern">
                        +
                    </button>
                    <button id="del-profile-btn" title="Ausgew√§hltes Profil l√∂schen">
                        -
                    </button>
                </div>
            </div>

            <!-- Haupt-Container f√ºr Einstellungen -->
            <details id="main-settings">
                <summary accesskey="e" title="Alt + e">
                    Einstellungen
                </summary>
                <div class="details-content">
                    <details id="settings-details" open>
                        <summary accesskey="v" title="Alt + v">
                            Voreinstellungen verwalten
                        </summary>
                        <div class="details-content">
                            <div class="control-group horizontal">
                                <label for="auto-save-local"
                                    title="Speichert Einstellungen verschl√ºsselt im Browser, damit sie beim n√§chsten Start geladen werden">Einstellungen
                                    automatisch merken</label>
                                <label class="switch">
                                    <input type="checkbox" id="auto-save-local" role="switch" aria-checked="true"
                                        checked />
                                    <span class="slider"></span>
                                </label>
                            </div>
                            <div class="control-group action-buttons config-buttons" style="margin-top: 0">
                                <button id="load-settings-btn" title="Einstellungen aus Datei laden">
                                    Laden
                                </button>
                                <button id="save-settings-btn" title="Alle Einstellungen in Datei speichern">
                                    Speichern
                                </button>
                                <input type="file" id="config-loader" accept=".json" style="display: none"
                                    aria-hidden="true" tabindex="-1" />
                            </div>
                        </div>
                    </details>

                    <details id="api-settings-details">
                        <summary accesskey="a" title="Alt + a">
                            API-Einstellungen
                        </summary>
                        <div class="details-content">
                            <div class="control-group">
                                <label for="pipeline-select">Pipeline</label>
                                <select id="pipeline-select">
                                    <option value="openai-openwebui" selected>
                                        OpenWebUI (OpenAI-API)
                                    </option>

                                    <option value="ollama-openwebui">
                                        OpenWebUI (Ollama-API)
                                    </option>

                                    <option value="ollama">Ollama</option>

                                    <option value="openai">
                                        OpenAI-kompatibel (z.B. LMStudio)
                                    </option>
                                </select>
                            </div>
                            <div class="control-group">
                                <label for="base-url">Basis-URL</label>
                                <input type="text" id="base-url"
                                    value="https://openwebui.sbbz-ilvesheim.de/api/chat/completions" />
                            </div>
                            <div class="control-group">
                                <label for="api-key">API-Schl√ºssel (optional)</label>
                                <input type="password" id="api-key" placeholder="Ihr API-Schl√ºssel" />
                            </div>
                            <div class="control-group">
                                <label for="model-name">Modell</label>
                                <div class="model-selection-group">
                                    <button id="fetch-models-btn" title="Modelle vom Server abrufen"
                                        aria-label="Modelle vom Server abrufen">
                                        Modelle abrufen
                                    </button>
                                    <select id="model-name">
                                        <!-- Options are now loaded dynamically -->
                                    </select>
                                </div>
                                <input type="text" id="custom-model-name" value="ministral-8b-bilderkennung"
                                    placeholder="Eigenen Modellnamen eingeben" style="display: none; margin-top: 5px"
                                    aria-label="Benutzerdefinierten Modellnamen eingeben" />
                            </div>
                            <div class="control-group horizontal">
                                <label for="temperature">Temperatur</label>
                                <input type="number" id="temperature" value="0.1" min="0" max="2" step="0.1"
                                    style="width: 80px" />
                            </div>
                            <div class="control-group horizontal">
                                <label for="repeat-penalty">Wiederholungsstrafe</label>
                                <input type="number" id="repeat-penalty" value="1.5" min="0" max="2" step="0.1"
                                    style="width: 80px" />
                            </div>
                            <div class="control-group horizontal">
                                <label for="top-p">Top P</label>
                                <input type="number" id="top-p" value="1.0" min="0" max="1" step="0.05"
                                    style="width: 80px" />
                            </div>
                            <div class="control-group horizontal">
                                <label for="top-k">Top K</label>
                                <input type="number" id="top-k" value="0" min="0" max="100" step="1"
                                    style="width: 80px" />
                            </div>
                        </div>
                    </details>

                    <details>
                        <summary accesskey="v" title="Alt + v">
                            Verarbeitungs-Einstellungen
                        </summary>
                        <div class="details-content">
                            <div class="control-group">
                                <label for="prompt">System-Prompt</label>
                                <textarea id="prompt">
* Extract all text in a logical order, as if you were reading it naturally.
* NEVER add additional sentences.
* Rebuild the headings.
* Format the text with markdown syntax.
* Don't translate text.
* Don't give answers to questions from the text.
* Don't solve math problems.
* Return what is on the page, NEVER add additional sentences, that describe your actions.
* Don't add ```markdown or ```
* Describe illustrations at their logical positions comprehensively in German. Use the following internal structure:

((Bild))<br/>
Art der Abbildung (z. B. Foto, Zeichnung, Diagramm):<br/>
Beschreibung: ‚Ä¶  / Bildtext: ‚Ä¶<br/>
((/Bild))

* Place captions and titles above the ((Bild))((/Bild)) tag if they exist in the source.
* Use LaTeX for ALL mathematical expressions.
* Put $$ around LaTeX sections.
* Put $ around LaTeX expressions embedded in text.
* Don't put [ or ] around LaTeX.
* Do the ocr twice and check if nothing is missing from the original page.
* Double check mathematical expressions for correctness.
* Double check if the markdown syntax is correct.
                        </textarea>
                            </div>

                            <div class="control-group horizontal">
                                <label for="dpi">PDF DPI</label>
                                <input type="number" id="dpi" value="150" min="72" step="1" />
                            </div>
                            <div class="control-group">
                                <label for="page-range">Seiten (z.B. 1, 3, 5-8) verarbeiten</label>
                                <input type="text" id="page-range" placeholder="F√ºr alle Seiten leer lassen." />
                            </div>
                            <div class="control-group horizontal">
                                <label for="toc-pages">Inhaltsverzeichnis auf Seiten</label>
                                <input type="text" id="toc-pages" placeholder="z.B. 2-4" style="width: 80px;" />
                            </div>
                            <div class="control-group horizontal">
                                <label for="toc-offset" title="Differenz zwischen PDF-Index und Buchseite.">Offset
                                    (Seiten ohne Nummerierung)</label>
                                <input type="number" id="toc-offset" value="0" style="width: 80px;" />
                            </div>
                            <p style="font-size: 0.85em; margin: 0; opacity: 0.8;">
                                <i>Info: PDF-Seite = Buchseite + Offset</i>
                            </p>
                            <button id="analyze-toc-btn" type="button" style="width: 100%; margin-top: 5px;">
                                Inhaltsverzeichnis analysieren
                            </button>
                            <div id="toc-status" style="font-size: 0.9em; margin-top: 5px; font-style: italic;"></div>

                            <div class="control-group horizontal">
                                <label for="enable-numbering">Nummerierung aktiv</label>
                                <label class="switch">
                                    <input type="checkbox" id="enable-numbering" checked role="switch"
                                        aria-checked="true" />
                                    <span class="slider"></span>
                                </label>
                            </div>
                            <div id="numbering-options">
                                <div class="control-group horizontal">
                                    <label for="start-pdf-page">Ab PDF-Seite</label>
                                    <input type="number" id="start-pdf-page" value="1" min="1" style="width: 80px" />
                                </div>
                                <div class="control-group horizontal">
                                    <label for="start-page-number">Mit Seitenzahl</label>
                                    <input type="number" id="start-page-number" value="1" min="1" style="width: 80px" />
                                </div>
                            </div>
                            <div class="control-group horizontal">
                                <label for="delay">Verz√∂gerung (ms)</label>
                                <input type="number" id="delay" value="100" min="0" step="100" style="width: 80px" />
                            </div>
                            <div class="control-group horizontal">
                                <label for="retries">API Neuversuche</label>
                                <input type="number" id="retries" value="1" min="0" step="1" style="width: 80px" />
                            </div>
                        </div>
                    </details>
                    <details>
                        <summary accesskey="c" title="Alt + c">
                            Aufnahme-Einstellungen
                        </summary>
                        <div class="details-content">
                            <div class="control-group">
                                <label for="camera-select">Kamera ausw√§hlen</label>
                                <select id="camera-select">
                                    <option value="" disabled selected>
                                        Klicken zum Laden der Kameras...
                                    </option>
                                </select>
                            </div>
                            <div class="control-group horizontal">
                                <label for="camera-res-full">Volle Kamera-Aufl√∂sung verwenden</label>
                                <label class="switch">
                                    <input type="checkbox" id="camera-res-full" role="switch" aria-checked="false" />
                                    <span class="slider"></span>
                                </label>
                            </div>
                            <div class="control-group" id="camera-pixel-group">
                                <label for="camera-max-pixels">Ziel-Aufl√∂sung (Pixel gesamt)</label>
                                <input type="number" id="camera-max-pixels" value="1000000" min="100000" step="100000"
                                    title="Beispiel: 1000000 entspricht ca. 1 Megapixel" />
                            </div>
                            <div class="control-group horizontal">
                                <label for="camera-auto-process"
                                    title="Wenn aktiv, startet die Verarbeitung direkt nach dem Schlie√üen der Kamera.">Nach
                                    Aufnahmeabschluss sofort
                                    verarbeiten</label>
                                <label class="switch">
                                    <input type="checkbox" id="camera-auto-process" role="switch"
                                        aria-checked="false" />
                                    <span class="slider"></span>
                                </label>
                            </div>
                            <div class="control-group horizontal">
                                <label for="camera-auto-save"
                                    title="L√§dt das DOCX automatisch herunter, wenn die Verarbeitung fertig ist.">Nach
                                    Verarbeitung automatisch speichern
                                    (DOCX)</label>
                                <label class="switch">
                                    <input type="checkbox" id="camera-auto-save" role="switch" aria-checked="false" />
                                    <span class="slider"></span>
                                </label>
                            </div>
                            <div class="control-group horizontal">
                                <label for="camera-auto-read"
                                    title="Liest das Ergebnis automatisch vor, wenn die Verarbeitung fertig ist.">Nach
                                    Verarbeitung automatisch
                                    vorlesen</label>
                                <label class="switch">
                                    <input type="checkbox" id="camera-auto-read" role="switch" aria-checked="false" />
                                    <span class="slider"></span>
                                </label>
                            </div>
                            <div class="control-group horizontal">
                                <label for="camera-auto-vision-mode"
                                    title="Schaltet den 'Was sehe ich'-Modus automatisch ein, wenn die Kamera ge√∂ffnet wird.">"Was
                                    sehe ich"-Modus aktivieren</label>
                                <label class="switch">
                                    <input type="checkbox" id="camera-auto-vision-mode" role="switch" />
                                    <span class="slider"></span>
                                </label>
                            </div>
                            <div class="control-group">
                                <label for="vision-prompt">Vision-Prompt ("Was sehe
                                    ich?"-Modus)</label>
                                <textarea id="vision-prompt">
* Describe what can be seen in the image accurately and helpfully.
* Be concise, but don't leave out any important details.
* Respond directly to the user (you).
* Speak German.
* Don't format the text.
                                    </textarea>
                            </div>
                        </div>
                    </details>

                    <details>
                        <summary accesskey="x" title="Alt + x">
                            DOCX-Export-Optionen
                        </summary>
                        <div class="details-content">
                            <!-- Neue Option 4a: Spaces in LaTeX Block -->
                            <div class="control-group horizontal">
                                <label for="docx-opt-latex-space-block"
                                    title="Entfernt alle Leerzeichen innerhalb von $$...$$ Bl√∂cken.">Leerzeichen in
                                    $$...$$ entfernen</label>
                                <label class="switch">
                                    <input type="checkbox" id="docx-opt-latex-space-block" checked role="switch"
                                        aria-checked="true" />
                                    <span class="slider"></span>
                                </label>
                            </div>
                            <!-- Neue Option 4b: Spaces in LaTeX Inline -->
                            <div class="control-group horizontal">
                                <label for="docx-opt-latex-space-inline"
                                    title="Entfernt alle Leerzeichen innerhalb von $...$ Bl√∂cken.">Leerzeichen in $...$
                                    entfernen</label>
                                <label class="switch">
                                    <input type="checkbox" id="docx-opt-latex-space-inline" checked role="switch"
                                        aria-checked="true" />
                                    <span class="slider"></span>
                                </label>
                            </div>

                            <div class="control-group horizontal">
                                <label for="docx-opt-unit-cm"
                                    title='Wandelt "\text{ m/cm/mm/km}" in "m/cm/mm/km" um'>Einheiten (\text{})
                                    bereinigen</label>
                                <label class="switch">
                                    <input type="checkbox" id="docx-opt-unit-cm" checked role="switch"
                                        aria-checked="true" />
                                    <span class="slider"></span>
                                </label>
                            </div>
                            <div class="control-group horizontal">
                                <label for="docx-opt-unit-circ" title='Wandelt "^circ" in "¬∞" um'>"^circ" zu "¬∞"</label>
                                <label class="switch">
                                    <input type="checkbox" id="docx-opt-unit-circ" checked role="switch"
                                        aria-checked="true" />
                                    <span class="slider"></span>
                                </label>
                            </div>
                            <div class="control-group horizontal">
                                <label for="docx-opt-greek"
                                    title="Wandelt Œ±, Œ≤, Œì... in \alpha, \beta, \Gamma... um">Griechische Buchstaben zu
                                    LaTeX</label>
                                <label class="switch">
                                    <input type="checkbox" id="docx-opt-greek" checked role="switch"
                                        aria-checked="true" />
                                    <span class="slider"></span>
                                </label>
                            </div>
                            <!-- Neue Option 2: Hoch/Tiefgestellte Zahlen -->
                            <div class="control-group horizontal">
                                <label for="docx-opt-supsub"
                                    title="Wandelt ¬≤ in ^2 und ‚ÇÉ in _3 etc. um">Hoch-/Tiefgestellte Zahlen zu
                                    LaTeX</label>
                                <label class="switch">
                                    <input type="checkbox" id="docx-opt-supsub" checked role="switch"
                                        aria-checked="true" />
                                    <span class="slider"></span>
                                </label>
                            </div>
                            <!-- Neue Option 3: Nicht-ASCII zu Latex -->
                            <div class="control-group horizontal">
                                <label for="docx-opt-nonascii"
                                    title="Wandelt Zeichen wie √ó, √∑, ‚â§, ‚â•, ‚â† in LaTeX-Befehle um">Sonderzeichen (nicht
                                    ASCII) zu
                                    LaTeX</label>
                                <label class="switch">
                                    <input type="checkbox" id="docx-opt-nonascii" checked role="switch"
                                        aria-checked="true" />
                                    <span class="slider"></span>
                                </label>
                            </div>

                            <div class="control-group horizontal">
                                <label for="docx-opt-nbsp-narrow"
                                    title="Ersetzt gesch√ºtztes Leerzeichen durch schmales gesch√ºtztes Leerzeichen">U+00A0
                                    zu U+202F (NBSP)</label>
                                <label class="switch">
                                    <input type="checkbox" id="docx-opt-nbsp-narrow" checked role="switch"
                                        aria-checked="true" />
                                    <span class="slider"></span>
                                </label>
                            </div>
                            <div class="control-group horizontal">
                                <label for="docx-opt-latex" title="Ersetzt $$...$$ durch <L>...</L>">$$ zu
                                    &lt;L&gt;&lt;/L&gt;</label>
                                <label class="switch">
                                    <input type="checkbox" id="docx-opt-latex" checked role="switch"
                                        aria-checked="true" />
                                    <span class="slider"></span>
                                </label>
                            </div>
                            <div class="control-group horizontal">
                                <label for="docx-opt-dollar" title="Entfernt alle $ Zeichen">$ Zeichen entfernen</label>
                                <label class="switch">
                                    <input type="checkbox" id="docx-opt-dollar" checked role="switch"
                                        aria-checked="true" />
                                    <span class="slider"></span>
                                </label>
                            </div>
                            <div class="control-group horizontal">
                                <label for="docx-opt-cdot" title="Ersetzt \cdot durch *">\cdot zu *</label>
                                <label class="switch">
                                    <input type="checkbox" id="docx-opt-cdot" checked role="switch"
                                        aria-checked="true" />
                                    <span class="slider"></span>
                                </label>
                            </div>
                            <div class="control-group horizontal">
                                <label for="docx-opt-images"
                                    title="Ersetzt ((Bild)) Tags durch XML Tags">((Bild))((/Bild)) zu
                                    &lt;Bild&gt;&lt;/Bild&gt;</label>
                                <label class="switch">
                                    <input type="checkbox" id="docx-opt-images" checked role="switch"
                                        aria-checked="true" />
                                    <span class="slider"></span>
                                </label>
                            </div>
                            <div class="control-group horizontal">
                                <label for="docx-opt-dashes" title="Entfernt Zeilen, die nur --- enthalten">Trennlinien
                                    "---" entfernen</label>
                                <label class="switch">
                                    <input type="checkbox" id="docx-opt-dashes" checked role="switch"
                                        aria-checked="true" />
                                    <span class="slider"></span>
                                </label>
                            </div>
                            <div class="control-group horizontal">
                                <label for="docx-opt-tables" title="F√ºgt <Tabelle> Tags um HTML-Tabellen ein">Tabellen
                                    markieren</label>
                                <label class="switch">
                                    <input type="checkbox" id="docx-opt-tables" checked role="switch"
                                        aria-checked="true" />
                                    <span class="slider"></span>
                                </label>
                            </div>
                            <div class="control-group horizontal">
                                <label for="docx-opt-quotes" title="Ersetzt ‚Äû‚Äú ‚Äö‚Äò durch standard &quot; und '">‚Äû‚Äú ‚Äö‚Äò zu
                                    '"</label>
                                <label class="switch">
                                    <input type="checkbox" id="docx-opt-quotes" checked role="switch"
                                        aria-checked="true" />
                                    <span class="slider"></span>
                                </label>
                            </div>
                            <div class="control-group horizontal">
                                <label for="docx-opt-hyphens" title="Ersetzt ‚Äì und ‚Äî durch -">Bindestriche
                                    normalisieren</label>
                                <label class="switch">
                                    <input type="checkbox" id="docx-opt-hyphens" checked role="switch"
                                        aria-checked="true" />
                                    <span class="slider"></span>
                                </label>
                            </div>
                            <div class="control-group horizontal">
                                <label for="docx-opt-whitespace"
                                    title="Ersetzt gesch√ºtzte Leerzeichen etc. durch Standard-Leerzeichen">Whitespace
                                    normalisieren</label>
                                <label class="switch">
                                    <input type="checkbox" id="docx-opt-whitespace" checked role="switch"
                                        aria-checked="true" />
                                    <span class="slider"></span>
                                </label>
                            </div>
                        </div>
                    </details>
                </div>
                <!-- End Details Content (Main Settings) -->
            </details>

            <div class="ai-disclaimer">
                Antworten sind KI generiert und k√∂nnen fehlerhaft sein.
                Bitte √ºberpr√ºfen Sie alle Informationen kritisch.
            </div>
        </div>

        <!-- Rechte Spalte: Inhalt -->
        <div class="main-content">
            <div class="preview-controls">
                <button id="toggle-raw" class="active" aria-pressed="true" accesskey="r" title="Alt + r">
                    Rohtext
                </button>
                <button id="toggle-rendered" aria-pressed="false" accesskey="g" title="Alt + g">
                    Gerenderter Text
                </button>
                <!-- TTS Button -->
                <button id="tts-btn" accesskey="t" title="Vorlesen (Shortcut: t)">
                    üîä Vorlesen
                </button>
            </div>
            <div class="preview-area">
                <div class="preview-panel">
                    <div class="preview-panel-header">
                        <h3>Text der zuletzt bearbeiteten Seite</h3>
                        <button id="copy-preview-btn" title="Inhalt in die Zwischenablage kopieren (Alt + y)"
                            accesskey="y">
                            üìã Kopieren
                        </button>
                    </div>
                    <textarea id="raw-preview" aria-label="Textvorschau"></textarea>
                    <div id="rendered-preview" style="display: none" tabindex="0" aria-label="Gerenderte Vorschau">
                    </div>
                </div>
                <div class="preview-panel">
                    <div class="preview-panel-header">
                        <h3>Bild der Seite</h3>
                        <!-- NEW NAVIGATION CONTROLS -->
                        <div class="img-nav-controls" id="img-nav-controls" style="display: none">
                            <button id="img-prev-btn" title="Vorheriges Bild">
                                &lt;
                            </button>
                            <div style="
                                        display: flex;
                                        align-items: center;
                                        gap: 5px;
                                    ">
                                <input type="number" id="img-nav-input" min="1" value="0" aria-label="Gehe zu Seite" />
                                <span id="img-total-count">/ 0</span>
                            </div>
                            <button id="img-next-btn" title="N√§chstes Bild">
                                &gt;
                            </button>
                        </div>
                    </div>
                    <img id="image-preview" />
                </div>
            </div>

            <!-- Fortschrittsanzeige -->
            <div class="progress-wrapper" id="progress-wrapper" role="status" aria-live="polite">
                <div class="progress-info">
                    <span id="progress-text">Seite 0 von 0</span>
                    <span id="eta-text">Verbleibend: --:--</span>
                </div>
                <div class="progress-container" role="progressbar" aria-valuemin="0" aria-valuemax="100"
                    aria-valuenow="0" aria-labelledby="progress-text">
                    <div class="progress-fill" id="progress-fill"></div>
                </div>
            </div>

            <!-- ARIA Live Region f√ºr Log -->
            <pre id="log" class="log-area" aria-live="polite" aria-atomic="false" tabindex="0" aria-label="Protokoll"
                accesskey="p" title="Alt + p">
Willkommen! Bitte Dateien ausw√§hlen oder ein Foto machen und auf "Starten" klicken.</pre>
        </div>
    </div>
    <canvas id="pdf-canvas"></canvas>

    <!-- PASSWORT MODAL DIALOG -->
    <div id="password-modal" class="modal-overlay" style="display: none">
        <div class="modal-content">
            <h3 id="modal-title">Passwort erforderlich</h3>
            <p id="modal-message">Bitte Passwort eingeben:</p>
            <input type="password" id="modal-input" placeholder="Passwort" autocomplete="off"
                aria-labelledby="modal-message" />
            <div class="modal-buttons">
                <button id="modal-cancel" class="btn-cancel">
                    Abbrechen
                </button>
                <button id="modal-ok">OK</button>
            </div>
        </div>
    </div>

    <!-- Shortcuts Modal -->
    <div id="shortcuts-modal" class="modal-overlay" style="display: none">
        <div class="modal-content">
            <h3>Tastaturk√ºrzel (Shortcuts)</h3>
            <div class="shortcut-list">
                <div class="shortcut-key">Alt + S</div>
                <div>Verarbeitung Start/Stop</div>
                <div class="shortcut-key">Alt + K</div>
                <div>Kamera √∂ffnen</div>
                <div class="shortcut-key">Alt + D</div>
                <div>Datei ausw√§hlen</div>
                <div class="shortcut-key">Alt + M</div>
                <div>Manuellen Prompt eingeben</div>
                <div class="shortcut-key">Alt + H</div>
                <div>Markdown herunterladen</div>
                <div class="shortcut-key">Alt + W</div>
                <div>Word (DOCX) herunterladen</div>
                <div class="shortcut-key">Alt + Q</div>
                <div>Profil Schnellwahl</div>
                <div class="shortcut-key">Alt + L</div>
                <div>Hell/Dunkel Modus</div>
                <div class="shortcut-key">Alt + T</div>
                <div>Vorlesen (TTS)</div>
                <div class="shortcut-key">Alt + Y</div>
                <div>Text kopieren</div>
                <div class="shortcut-key">Alt + R</div>
                <div>Ansicht Rohtext</div>
                <div class="shortcut-key">Alt + G</div>
                <div>Ansicht Gerendert</div>
                <div class="shortcut-key">Alt + E</div>
                <div>Einstellungen √∂ffnen</div>
            </div>
            <div class="modal-buttons">
                <button onclick="
                            document.getElementById(
                                'shortcuts-modal',
                            ).style.display = 'none'
                        ">
                    Schlie√üen
                </button>
            </div>
        </div>
    </div>

    <!-- KAMERA MODAL DIALOG -->
    <div id="camera-modal" class="modal-overlay" style="display: none">
        <div class="modal-content large" style="
                    position: relative;
                    display: flex;
                    flex-direction: column;
                    max-height: 95vh;
                ">
            <div style="
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        margin-bottom: 10px;
                    ">
                <h3>Foto aufnehmen</h3>

                <!-- Vision Mode Toggle & Mute -->
                <div class="control-group horizontal" style="
                            background: var(--input-bg);
                            padding: 5px 10px;
                            border-radius: 4px;
                            border: 1px solid var(--border-color);
                        ">
                    <!-- Vision Switch -->
                    <label for="vision-mode-toggle" style="margin-right: 5px; font-size: 0.9em">üëÅÔ∏è Vision</label>
                    <label class="switch">
                        <input type="checkbox" id="vision-mode-toggle" role="switch" />
                        <span class="slider"></span>
                    </label>

                    <!-- Spacer -->
                    <div style="width: 15px"></div>

                    <!-- Mute Switch -->
                    <label for="vision-mute-toggle" style="margin-right: 5px; font-size: 0.9em">üîá Stumm</label>
                    <label class="switch">
                        <input type="checkbox" id="vision-mute-toggle" role="switch" />
                        <span class="slider"></span>
                    </label>
                </div>
            </div>

            <div id="camera-batch-counter">Stapel: 0</div>

            <!-- Videostream -->
            <div style="
                        position: relative;
                        flex-shrink: 0;
                        min-height: 200px;
                    ">
                <video id="camera-stream" autoplay playsinline style="
                            width: 100%;
                            max-height: 40vh;
                            object-fit: contain;
                            background: #000;
                            border-radius: 4px;
                        "></video>
            </div>

            <!-- Vision Chat Area (Nur sichtbar im Vision Mode) -->
            <div id="vision-ui-container" style="
                        display: none;
                        flex-direction: column;
                        flex-grow: 1;
                        margin-top: 10px;
                        min-height: 0;
                    ">
                <div id="vision-response-area" style="
                            flex-grow: 1;
                            overflow-y: auto;
                            background: var(--input-bg);
                            padding: 10px;
                            border: 1px solid var(--border-color);
                            border-radius: 4px;
                            margin-bottom: 5px;
                            font-size: 0.95em;
                            white-space: pre-wrap;
                        ">
                    Warte auf Aufnahme...
                </div>

                <div style="display: flex; gap: 5px">
                    <input type="text" id="vision-user-input" placeholder="Frage zum Bild stellen..." disabled />
                    <button id="vision-send-btn" disabled>Senden</button>
                </div>
            </div>

            <p id="camera-status" style="margin: 5px 0; font-size: 0.9em; min-height: 1.2em"></p>

            <div class="modal-buttons" style="margin-top: auto">
                <button id="camera-close" class="btn-cancel">
                    Schlie√üen
                </button>
                <button id="camera-snap">Foto machen</button>
            </div>
        </div>
    </div>

    <!-- Hidden Canvas for Camera Resize -->
    <canvas id="camera-canvas" style="display: none"></canvas>

    <script>
        // --- Service Worker Registration ---
        if ("serviceWorker" in navigator) {
            navigator.serviceWorker
                .register("sw.js")
                .then((reg) =>
                    console.log("Service Worker registriert", reg),
                )
                .catch((err) =>
                    console.error("Service Worker Fehler", err),
                );
        }

        // --- DOM-Elemente ---
        const fileInput = document.getElementById("file-input");
        const pipelineSelect = document.getElementById("pipeline-select");
        const baseUrlInput = document.getElementById("base-url");
        const modelNameSelect = document.getElementById("model-name");
        const customModelNameInput =
            document.getElementById("custom-model-name");
        const fetchModelsBtn = document.getElementById("fetch-models-btn");
        const apiKeyInput = document.getElementById("api-key");
        const promptInput = document.getElementById("prompt");
        const dpiInput = document.getElementById("dpi");
        const pageRangeInput = document.getElementById("page-range");
        const enableNumberingInput =
            document.getElementById("enable-numbering");
        const numberingOptions =
            document.getElementById("numbering-options");
        const startPdfPageInput = document.getElementById("start-pdf-page");
        const startPageNumberInput =
            document.getElementById("start-page-number");
        const delayInput = document.getElementById("delay");
        const retriesInput = document.getElementById("retries");
        const temperatureInput = document.getElementById("temperature");
        const repeatPenaltyInput =
            document.getElementById("repeat-penalty");
        const topPInput = document.getElementById("top-p");
        const topKInput = document.getElementById("top-k");

        // Manual Prompt
        const manualPromptInput = document.getElementById("manual-prompt");
        const copyPreviewBtn = document.getElementById("copy-preview-btn");

        // Image Navigation
        const imgNavControls = document.getElementById("img-nav-controls");
        const imgPrevBtn = document.getElementById("img-prev-btn");
        const imgNextBtn = document.getElementById("img-next-btn");
        const imgNavInput = document.getElementById("img-nav-input");
        const imgTotalCount = document.getElementById("img-total-count");

        // Quick Settings Elements
        const quickSettingsSelect = document.getElementById(
            "quick-settings-select",
        );
        const addProfileBtn = document.getElementById("add-profile-btn");
        const delProfileBtn = document.getElementById("del-profile-btn");
        const mainSettings = document.getElementById("main-settings");
        const apiSettingsDetails = document.getElementById(
            "api-settings-details",
        );
        const fileNameDisplay =
            document.getElementById("file-name-display");

        // Camera Configuration Elements
        const cameraSelect = document.getElementById("camera-select");
        const cameraResFull = document.getElementById("camera-res-full");
        const cameraMaxPixels =
            document.getElementById("camera-max-pixels");
        const cameraPixelGroup =
            document.getElementById("camera-pixel-group");
        const cameraAutoProcess = document.getElementById(
            "camera-auto-process",
        );

        // Referenzen f√ºr die neuen Checkboxen
        const cameraAutoSave = document.getElementById("camera-auto-save");
        const cameraAutoRead = document.getElementById("camera-auto-read");
        const cameraAutoVisionMode = document.getElementById(
            "camera-auto-vision-mode",
        );

        // Button Elements
        const toggleProcessingBtn = document.getElementById(
            "toggle-processing-btn",
        );
        const downloadMdBtn = document.getElementById("download-md-btn");
        const downloadDocxBtn =
            document.getElementById("download-docx-btn");
        const toggleRawBtn = document.getElementById("toggle-raw");
        const toggleRenderedBtn =
            document.getElementById("toggle-rendered");
        const ttsBtn = document.getElementById("tts-btn"); // TTS Button
        const imagePreview = document.getElementById("image-preview");
        const rawPreview = document.getElementById("raw-preview");
        const renderedPreview = document.getElementById("rendered-preview");
        const logEl = document.getElementById("log");
        const pdfCanvas = document.getElementById("pdf-canvas");
        const themeToggleBtn = document.getElementById("theme-toggle");

        // Camera Elements
        const cameraBtn = document.getElementById("camera-btn");
        const cameraModal = document.getElementById("camera-modal");
        const cameraStream = document.getElementById("camera-stream");
        const cameraCloseBtn = document.getElementById("camera-close");
        const cameraSnapBtn = document.getElementById("camera-snap");
        const cameraCanvas = document.getElementById("camera-canvas");
        const cameraStatus = document.getElementById("camera-status");
        const cameraBatchCounter = document.getElementById(
            "camera-batch-counter",
        );

        const cameraFileStatus =
            document.getElementById("camera-file-status");
        const cameraStatusText =
            document.getElementById("camera-status-text");
        const clearCameraBtn = document.getElementById("clear-camera-btn");

        let cameraStreamObj = null;
        let cameraQueue = []; // Liste f√ºr Batch-Aufnahmen
        let cameraListLoaded = false;

        // DOM Elemente f√ºr Vision Mode
        const visionPromptInput = document.getElementById("vision-prompt");
        const visionMuteToggle =
            document.getElementById("vision-mute-toggle");
        const visionModeToggle =
            document.getElementById("vision-mode-toggle");
        const visionUiContainer = document.getElementById(
            "vision-ui-container",
        );
        const visionResponseArea = document.getElementById(
            "vision-response-area",
        );
        const visionUserInput =
            document.getElementById("vision-user-input");
        const visionSendBtn = document.getElementById("vision-send-btn");

        let currentVisionBase64 = null; // Speichert das aktuelle Bild f√ºr R√ºckfragen

        // Inhaltsverzeichnis (ToC) State
        let globalToc = [];

        // Preview Queue (for Navigation)
        let previewItems = []; // Contains {type: 'pdf'|'image'|'camera', ...}
        let currentPreviewIndex = 0;

        // Flags f√ºr die Automatisierung
        let shouldAutoSave = false;
        let shouldAutoRead = false;
        let wasAutoProcessed = false;

        // Global Variables for State
        let lastProcessedImageBase64 = null; // F√ºr das manuelle Prompten
        let lastProcessedIndex = -1;

        // Progress Elements
        const progressWrapper = document.getElementById("progress-wrapper");
        const progressText = document.getElementById("progress-text");
        const etaText = document.getElementById("eta-text");
        const progressFill = document.getElementById("progress-fill");
        const progressContainer = document.querySelector(
            ".progress-container",
        );

        // DOCX Option Inputs
        const docxOptUnitCm = document.getElementById("docx-opt-unit-cm");
        const docxOptUnitCirc =
            document.getElementById("docx-opt-unit-circ");
        const docxOptGreek = document.getElementById("docx-opt-greek");
        // New Options:
        const docxOptSupsub = document.getElementById("docx-opt-supsub");
        const docxOptNonAscii =
            document.getElementById("docx-opt-nonascii");
        const docxOptLatexSpaceBlock = document.getElementById(
            "docx-opt-latex-space-block",
        );
        const docxOptLatexSpaceInline = document.getElementById(
            "docx-opt-latex-space-inline",
        );

        const docxOptNbspNarrow = document.getElementById(
            "docx-opt-nbsp-narrow",
        );

        const docxOptLatex = document.getElementById("docx-opt-latex");
        const docxOptDollar = document.getElementById("docx-opt-dollar");
        const docxOptCdot = document.getElementById("docx-opt-cdot");
        const docxOptImages = document.getElementById("docx-opt-images");
        const docxOptDashes = document.getElementById("docx-opt-dashes");
        const docxOptTables = document.getElementById("docx-opt-tables");
        const docxOptQuotes = document.getElementById("docx-opt-quotes");
        const docxOptHyphens = document.getElementById("docx-opt-hyphens");
        const docxOptWhitespace = document.getElementById(
            "docx-opt-whitespace",
        );

        // Save/Load Buttons
        const saveSettingsBtn =
            document.getElementById("save-settings-btn");
        const loadSettingsBtn =
            document.getElementById("load-settings-btn");
        const configLoader = document.getElementById("config-loader");
        const autoSaveLocalCheckbox =
            document.getElementById("auto-save-local");

        // Modal Elements
        const passwordModal = document.getElementById("password-modal");
        const modalInput = document.getElementById("modal-input");
        const modalMessage = document.getElementById("modal-message");
        const modalOkBtn = document.getElementById("modal-ok");
        const modalCancelBtn = document.getElementById("modal-cancel");

        toggleProcessingBtn.disabled = true;

        // Logo Listener f√ºr Shortcuts
        document
            .querySelector(".header-logo")
            .addEventListener("click", () => {
                document.getElementById("shortcuts-modal").style.display =
                    "flex";
            });

        // --- Theme / Design Logic ---
        function initTheme() {
            const prefersLight = window.matchMedia(
                "(prefers-color-scheme: light)",
            ).matches;
            if (prefersLight) {
                document.documentElement.classList.add("light-theme");
                updateThemeIcon(true);
            } else {
                document.documentElement.classList.remove("light-theme");
                updateThemeIcon(false);
            }

            window
                .matchMedia("(prefers-color-scheme: light)")
                .addEventListener("change", (event) => {
                    const newColorScheme = event.matches ? "light" : "dark";
                    if (newColorScheme === "light") {
                        document.documentElement.classList.add(
                            "light-theme",
                        );
                        updateThemeIcon(true);
                    } else {
                        document.documentElement.classList.remove(
                            "light-theme",
                        );
                        updateThemeIcon(false);
                    }
                });
        }

        function toggleTheme() {
            const isLight =
                document.documentElement.classList.toggle("light-theme");
            updateThemeIcon(isLight);
            // Trigger save when theme changes
            saveToLocalStorage();
        }

        function updateThemeIcon(isLight) {
            // If light -> Show moon to switch to dark
            // If dark -> Show sun to switch to light
            themeToggleBtn.innerHTML = isLight
                ? '<span aria-hidden="true">üåô</span>'
                : '<span aria-hidden="true">‚òÄÔ∏è</span>';
            themeToggleBtn.setAttribute(
                "aria-label",
                isLight
                    ? "Zu dunklem Design wechseln"
                    : "Zu hellem Design wechseln",
            );
        }

        themeToggleBtn.addEventListener("click", toggleTheme);

        // --- TEXT TO SPEECH (TTS) LOGIC ---

        function initTTS() {
            if (!("speechSynthesis" in window)) {
                ttsBtn.style.display = "none";
                return;
            }
            let voices = [];
            function loadVoices() {
                voices = window.speechSynthesis.getVoices();
            }
            loadVoices();
            if (window.speechSynthesis.onvoiceschanged !== undefined) {
                window.speechSynthesis.onvoiceschanged = loadVoices;
            }

            function detectLanguage(text) {
                if (!text) return "de-DE";
                const t = text.toLowerCase();
                const deWords = [
                    "der",
                    "die",
                    "das",
                    "und",
                    "ist",
                    "nicht",
                    "mit",
                    "den",
                    "von",
                ];
                const enWords = [
                    "the",
                    "and",
                    "is",
                    "not",
                    "with",
                    "for",
                    "you",
                    "that",
                    "this",
                ];
                let deCount = 0,
                    enCount = 0;
                const words = t.split(/\s+/).slice(0, 100);
                words.forEach((word) => {
                    if (deWords.includes(word)) deCount++;
                    if (enWords.includes(word)) enCount++;
                });
                if (enCount > deCount) return "en-US";
                return "de-DE";
            }

            function stopSpeaking() {
                window.speechSynthesis.cancel();
                ttsBtn.textContent = "üîä Vorlesen";
                ttsBtn.classList.remove("speaking");
            }

            function toggleSpeech() {
                if (window.speechSynthesis.speaking) {
                    stopSpeaking();
                } else {
                    const text = rawPreview.value;
                    if (!text.trim()) return;
                    const utterance = new SpeechSynthesisUtterance(text);
                    const langCode = detectLanguage(text);
                    const matchingVoice = voices.find((v) =>
                        v.lang.startsWith(langCode),
                    );
                    if (matchingVoice) utterance.voice = matchingVoice;
                    utterance.onend = () => stopSpeaking();
                    utterance.onerror = (e) => {
                        console.error("TTS Fehler", e);
                        stopSpeaking();
                    };
                    window.speechSynthesis.speak(utterance);
                    ttsBtn.textContent = "‚èπ Stoppen";
                    ttsBtn.classList.add("speaking");
                }
            }
            ttsBtn.addEventListener("click", toggleSpeech);
        }

        // --- COPY FUNCTIONALITY ---
        copyPreviewBtn.addEventListener("click", async () => {
            let textToCopy = "";
            if (toggleRawBtn.classList.contains("active")) {
                textToCopy = rawPreview.value;
            } else {
                textToCopy = renderedPreview.innerText;
            }
            if (!textToCopy) {
                logMessage("Kein Text zum Kopieren vorhanden.");
                return;
            }
            try {
                await navigator.clipboard.writeText(textToCopy);
                const originalText = copyPreviewBtn.innerHTML;
                copyPreviewBtn.innerHTML = "‚úÖ Kopiert!";
                setTimeout(() => {
                    copyPreviewBtn.innerHTML = originalText;
                }, 1500);
            } catch (err) {
                console.error("Fehler beim Kopieren: ", err);
            }
        });

        // --- GLOBAL HELPERS (Moved outside initApp for accessibility) ---

        function getBase64FromImage(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = (error) => reject(error);
                reader.readAsDataURL(file);
            });
        }

        async function getBase64FromPdfPage(pdfDoc, pageNum, dpi) {
            try {
                const page = await pdfDoc.getPage(pageNum);
                const viewport = page.getViewport({ scale: dpi / 72 });

                const canvas = document.getElementById("pdf-canvas");
                if (!canvas)
                    throw new Error("Interner PDF-Canvas nicht gefunden!");

                canvas.height = viewport.height;
                canvas.width = viewport.width;

                const context = canvas.getContext("2d");
                await page.render({
                    canvasContext: context,
                    viewport: viewport,
                }).promise;

                return canvas.toDataURL("image/jpeg", 0.9);
            } catch (e) {
                console.error("Fehler beim Rendern der PDF-Seite:", e);
                throw e;
            }
        }

        // --- CAMERA LOGIC ---

        cameraResFull.addEventListener("change", () => {
            cameraPixelGroup.style.display = cameraResFull.checked
                ? "none"
                : "flex";
            cameraResFull.setAttribute(
                "aria-checked",
                cameraResFull.checked,
            );
        });

        async function populateCameraList() {
            if (cameraListLoaded) return;
            try {
                const tempStream =
                    await navigator.mediaDevices.getUserMedia({
                        video: true,
                    });
                const devices =
                    await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(
                    (device) => device.kind === "videoinput",
                );
                tempStream.getTracks().forEach((track) => track.stop());
                cameraSelect.innerHTML = "";
                if (videoDevices.length > 0) {
                    videoDevices.forEach((device, index) => {
                        const option = document.createElement("option");
                        option.value = device.deviceId;
                        option.textContent =
                            device.label || `Kamera ${index + 1}`;
                        cameraSelect.appendChild(option);
                    });
                    const savedId = localStorage.getItem("last_camera_id");
                    if (
                        savedId &&
                        videoDevices.some((d) => d.deviceId === savedId)
                    ) {
                        cameraSelect.value = savedId;
                    }
                } else {
                    const option = document.createElement("option");
                    option.textContent = "Keine Kameras gefunden";
                    cameraSelect.appendChild(option);
                }
                cameraListLoaded = true;
            } catch (err) {
                console.error(
                    "Kamera-Zugriff f√ºr Liste fehlgeschlagen:",
                    err,
                );
                cameraSelect.innerHTML =
                    '<option value="" disabled>Zugriff erforderlich f√ºr Liste</option>';
            }
        }

        cameraSelect.addEventListener("mousedown", populateCameraList);

        cameraBtn.addEventListener("click", () => {
            if (cameraQueue.length > 0) {
                cameraQueue = [];
                updateCameraFileStatus();
                logMessage(
                    "Kamera ge√∂ffnet: Vorheriger Bilderstapel wurde verworfen.",
                );
            }
            startCamera();
        });

        async function startCamera() {
            cameraModal.style.display = "flex";
            // Pr√ºfen, ob Auto-Vision aktiv ist
            if (cameraAutoVisionMode && cameraAutoVisionMode.checked) {
                visionModeToggle.checked = true;
            } else {
                // Optional: Zur√ºcksetzen auf Standard (OCR), wenn Auto-Vision aus ist
                visionModeToggle.checked = false;
            }
            // WICHTIG: Change-Event ausl√∂sen, damit sich die UI (Chat-Fenster etc.) aktualisiert
            visionModeToggle.dispatchEvent(new Event("change"));
            cameraBatchCounter.style.display = "block";
            cameraBatchCounter.textContent = `Stapel: ${cameraQueue.length}`;
            cameraStatus.textContent = "Kamera wird gestartet...";

            const deviceId = cameraSelect.value;
            const constraints = {
                video:
                    deviceId && deviceId.length > 0
                        ? { deviceId: { exact: deviceId } }
                        : { facingMode: "environment" },
            };

            try {
                if (cameraStreamObj) stopCameraStreamOnly();
                cameraStreamObj =
                    await navigator.mediaDevices.getUserMedia(constraints);
                cameraStream.srcObject = cameraStreamObj;
                cameraStatus.textContent = "";

                if (!cameraListLoaded) {
                    const devices =
                        await navigator.mediaDevices.enumerateDevices();
                    const videoDevices = devices.filter(
                        (device) => device.kind === "videoinput",
                    );
                    if (
                        videoDevices.length > 0 &&
                        videoDevices[0].label !== ""
                    ) {
                        cameraSelect.innerHTML = "";
                        videoDevices.forEach((device, index) => {
                            const option = document.createElement("option");
                            option.value = device.deviceId;
                            option.textContent =
                                device.label || `Kamera ${index + 1}`;
                            cameraSelect.appendChild(option);
                        });
                        const track = cameraStreamObj.getVideoTracks()[0];
                        const currentId = track.getSettings().deviceId;
                        if (currentId) cameraSelect.value = currentId;
                        cameraListLoaded = true;
                    }
                }
            } catch (err) {
                console.error(err);
                cameraStatus.textContent =
                    "Fehler: Kamera konnte nicht gestartet werden. " +
                    err.message;
            }
        }

        function stopCameraStreamOnly() {
            if (cameraStreamObj) {
                cameraStreamObj
                    .getTracks()
                    .forEach((track) => track.stop());
                cameraStreamObj = null;
            }
        }

        function stopCameraModal() {
            stopCameraStreamOnly();
            cameraModal.style.display = "none";
            updateCameraFileStatus();

            // Load the new images into the preview system
            if (cameraQueue.length > 0) {
                loadPreviewContent();
            }

            // Focus Manual Prompt
            manualPromptInput.focus();

            if (cameraQueue.length > 0 && cameraAutoProcess.checked) {
                logMessage("Automatische Verarbeitung gestartet...");
                shouldAutoSave = cameraAutoSave.checked;
                shouldAutoRead = cameraAutoRead.checked;
                wasAutoProcessed = true;
                setTimeout(() => {
                    if (!isProcessing) toggleProcessingBtn.click();
                }, 500);
            }
        }

        cameraCloseBtn.addEventListener("click", stopCameraModal);
        cameraSelect.addEventListener("change", () => {
            localStorage.setItem("last_camera_id", cameraSelect.value);
        });

        // Toggle Event Listener
        visionModeToggle.addEventListener("change", () => {
            const isVision = visionModeToggle.checked;
            visionUiContainer.style.display = isVision ? "flex" : "none";
            cameraBatchCounter.style.display = isVision ? "none" : "block";

            // Button Text anpassen
            cameraSnapBtn.textContent = isVision
                ? "Anschauen & Fragen"
                : "Foto machen";
            if (isVision) {
                visionResponseArea.textContent =
                    "Bereit. Mach ein Foto, um zu starten.";
            }
        });

        // Sofort aufh√∂ren zu sprechen, wenn "Stumm" aktiviert wird
        visionMuteToggle.addEventListener("change", () => {
            if (visionMuteToggle.checked) {
                window.speechSynthesis.cancel();
            }
        });

        // Neuer Snap Handler
        cameraSnapBtn.addEventListener("click", async () => {
            if (!cameraStreamObj) return;

            // iOS TTS Unlock: Muss direkt im Click-Handler erfolgen
            unlockTTS();

            // 1. Bild vom Canvas holen
            const video = cameraStream;
            const canvas = cameraCanvas;
            let w = video.videoWidth;
            let h = video.videoHeight;

            // Resizing Logik
            if (!cameraResFull.checked) {
                const maxPixels =
                    parseInt(cameraMaxPixels.value) || 1000000;
                const currentPixels = w * h;
                if (currentPixels > maxPixels) {
                    const scale = Math.sqrt(maxPixels / currentPixels);
                    w = Math.floor(w * scale);
                    h = Math.floor(h * scale);
                }
            }
            canvas.width = w;
            canvas.height = h;
            const ctx = canvas.getContext("2d");
            ctx.drawImage(video, 0, 0, w, h);
            const base64 = canvas.toDataURL("image/jpeg", 0.85);

            if (visionModeToggle.checked) {
                // VISION MODE LOGIK
                currentVisionBase64 = base64; // Speichern f√ºr Chat
                visionResponseArea.innerHTML =
                    '<span class="vision-loading">Analysiere Bild...</span>';
                visionUserInput.disabled = true;
                visionSendBtn.disabled = true;

                // Sende an LLM (ohne Queue, direkt)
                // Wir nutzen den "vision-prompt" aus den Einstellungen
                const prompt = visionPromptInput.value;

                try {
                    const response = await sendToLLM(base64, 1, prompt);

                    visionResponseArea.textContent = response;
                    // Nur vorlesen, wenn nicht stumm geschaltet
                    if (!visionMuteToggle.checked) {
                        speakText(response);
                    }

                    // Chat aktivieren
                    visionUserInput.disabled = false;
                    visionSendBtn.disabled = false;
                    visionUserInput.focus();
                } catch (e) {
                    visionResponseArea.textContent = "Fehler: " + e.message;
                }
            } else {
                // NORMALE BATCH LOGIK (Bestehender Code)
                cameraQueue.push(base64);
                cameraBatchCounter.textContent = `Stapel: ${cameraQueue.length}`;

                const oldText = cameraSnapBtn.textContent;
                cameraSnapBtn.textContent = "Gespeichert!";
                cameraSnapBtn.style.backgroundColor =
                    "var(--success-color)";
                setTimeout(() => {
                    cameraSnapBtn.textContent = oldText;
                    cameraSnapBtn.style.backgroundColor = "";
                }, 800);
                updateCameraFileStatus();
            }
        });

        function updateCameraFileStatus() {
            if (cameraQueue.length > 0) {
                cameraFileStatus.style.display = "flex";
                cameraStatusText.textContent = `üì∑ ${cameraQueue.length} Foto(s) im Stapel`;
                fileNameDisplay.style.display = "none"; // Hide filename if camera active
                toggleProcessingBtn.disabled = false;
                fileInput.value = "";
                firstFileName = getTimestampFileName();
                logMessage(
                    `${cameraQueue.length} Foto(s) bereit f√ºr Verarbeitung.`,
                );
            } else {
                cameraFileStatus.style.display = "none";
                if (fileInput.files.length === 0) {
                    if (!lastProcessedImageBase64)
                        toggleProcessingBtn.disabled = true;
                }
            }
        }

        clearCameraBtn.addEventListener("click", () => {
            cameraQueue = [];
            previewItems = []; // Clear preview
            imagePreview.src = "";
            imgNavControls.style.display = "none";
            updateCameraFileStatus();
            logMessage("Foto-Stapel verworfen.");
        });

        function unlockTTS() {
            if (!("speechSynthesis" in window)) return;
            const u = new SpeechSynthesisUtterance(" ");
            u.volume = 0;
            window.speechSynthesis.speak(u);
        }

        function speakText(text) {
            if (!("speechSynthesis" in window)) return;
            window.speechSynthesis.cancel(); // Vorheriges abbrechen

            if (!text || !text.trim()) return;

            const utterance = new SpeechSynthesisUtterance(text);

            // Sprache erkennen (einfach)
            const isEnglish =
                /[a-z]/i.test(text) &&
                (text.match(/\b(the|and|is)\b/gi) || []).length >
                (text.match(/\b(der|die|das)\b/gi) || []).length;

            utterance.lang = isEnglish ? "en-US" : "de-DE";

            // Kurze Verz√∂gerung f√ºr Stimmen-Laden (besonders mobile)
            const voices = window.speechSynthesis.getVoices();
            if (voices.length > 0) {
                const matchingVoice = voices.find((v) =>
                    v.lang.startsWith(utterance.lang),
                );
                if (matchingVoice) utterance.voice = matchingVoice;
            }

            window.speechSynthesis.speak(utterance);
        }

        function getTimestampFileName() {
            const now = new Date();
            const y = now.getFullYear();
            const m = String(now.getMonth() + 1).padStart(2, "0");
            const d = String(now.getDate()).padStart(2, "0");
            const h = String(now.getHours()).padStart(2, "0");
            const min = String(now.getMinutes()).padStart(2, "0");
            return `OCR-Scan-${y}-${m}-${d}_${h}-${min}`;
        }

        // --- Pipeline Configs ---
        const pipelineConfigs = {
            "openai-openwebui": {
                baseUrl:
                    "https://openwebui.sbbz-ilvesheim.de/api/chat/completions",
            },

            "ollama-openwebui": {
                baseUrl:
                    "https://openwebui.sbbz-ilvesheim.de/ollama/api/generate",
            },

            ollama: {
                baseUrl: "http://localhost:11434/api/generate",
            },

            openai: {
                baseUrl: "http://localhost:1234/v1/chat/completions",
            },
        };

        function updateAriaChecked(e) {
            e.target.setAttribute("aria-checked", e.target.checked);
        }
        document.querySelectorAll('input[role="switch"]').forEach((el) => {
            el.addEventListener("change", updateAriaChecked);
        });

        function updateApiSettings() {
            const selectedPipeline = pipelineSelect.value;
            const config = pipelineConfigs[selectedPipeline];
            baseUrlInput.value = config.baseUrl;
            modelNameSelect.innerHTML =
                '<option value="" disabled selected>kein Modell gew√§hlt</option>';
            customModelNameInput.style.display = "none";
        }

        async function fetchModels() {
            const selectedPipeline = pipelineSelect.value;
            const baseUrl = baseUrlInput.value.trim();
            const apiKey = apiKeyInput.value.trim();
            let modelsUrl;
            // We check for both Ollama variants
            if (
                selectedPipeline === "ollama" ||
                selectedPipeline === "ollama-openwebui"
            ) {
                modelsUrl = baseUrl.replace(
                    /\/api\/generate\/?$/,
                    "/api/tags",
                );
            } else {
                // Covers 'openai' and 'openai-openwebui'
                modelsUrl = baseUrl.replace(
                    /\/chat\/completions\/?$/,
                    "/models",
                );
            }
            logMessage(`Rufe Modelle von ${modelsUrl} ab...`);
            fetchModelsBtn.disabled = true;
            fetchModelsBtn.textContent = "...";

            try {
                const headers = { "Content-Type": "application/json" };
                if (apiKey) headers["Authorization"] = `Bearer ${apiKey}`;

                const response = await fetch(modelsUrl, {
                    method: "GET",
                    headers: headers,
                });
                if (!response.ok)
                    throw new Error(`Serverantwort: ${response.status}`);
                const data = await response.json();
                let modelNames = [];

                // We check for both Ollama variants
                if (
                    (selectedPipeline === "ollama" ||
                        selectedPipeline === "ollama-openwebui") &&
                    data.models
                ) {
                    modelNames = data.models
                        .map((model) => model.name)
                        .sort();
                } else if (
                    (selectedPipeline === "openai" ||
                        selectedPipeline === "openai-openwebui") &&
                    data.data
                ) {
                    modelNames = data.data.map((model) => model.id).sort();
                } else {
                    throw new Error(
                        "Unerwartetes Antwortformat vom Server.",
                    );
                }
                populateModelSelect(modelNames);
                logMessage(
                    `${modelNames.length} Modell(e) erfolgreich geladen.`,
                );
            } catch (error) {
                logMessage(
                    `Fehler beim Abrufen der Modelle: ${error.message}`,
                );
                modelNameSelect.innerHTML =
                    '<option value="" disabled selected>Abruf fehlgeschlagen</option>';
                populateModelSelect([]);
            } finally {
                fetchModelsBtn.disabled = false;
                fetchModelsBtn.textContent = "Modelle abrufen";
            }
        }

        function populateModelSelect(models) {
            modelNameSelect.innerHTML = "";
            if (models.length > 0) {
                models.forEach((modelName) => {
                    const option = document.createElement("option");
                    option.value = modelName;
                    option.textContent = modelName;
                    modelNameSelect.appendChild(option);
                });
            } else {
                const option = document.createElement("option");
                option.textContent = "Keine Modelle gefunden";
                option.disabled = true;
                modelNameSelect.appendChild(option);
            }
            const customOption = document.createElement("option");
            customOption.value = "";
            // Cosmetic update
            const pipelineName = pipelineSelect.value.includes("ollama")
                ? "Ollama"
                : "OpenAI";
            customOption.textContent = `Benutzerdefiniert ${pipelineName}...`;
            modelNameSelect.appendChild(customOption);
            modelNameSelect.dispatchEvent(new Event("change"));
        }

        modelNameSelect.addEventListener("change", () => {
            customModelNameInput.style.display =
                modelNameSelect.value === "" ? "block" : "none";
        });

        enableNumberingInput.addEventListener("change", () => {
            numberingOptions.style.display = enableNumberingInput.checked
                ? "flex"
                : "none";
            enableNumberingInput.setAttribute(
                "aria-checked",
                enableNumberingInput.checked,
            );
        });

        pipelineSelect.addEventListener("change", updateApiSettings);
        fetchModelsBtn.addEventListener("click", fetchModels);

        // --- EINSTELLUNGEN & PROFILE MANAGEMENT ---

        const settingsIds = [
            "pipeline-select",
            "base-url",
            "model-name",
            "custom-model-name",
            "api-key",
            "temperature",
            "repeat-penalty",
            "top-p",
            "top-k",
            "prompt",
            "dpi",
            "page-range",
            "enable-numbering",
            "start-pdf-page",
            "start-page-number",
            "delay",
            "retries",
            "docx-opt-latex",
            "docx-opt-dollar",
            "docx-opt-cdot",
            "docx-opt-images",
            "docx-opt-dashes",
            "docx-opt-tables",
            "docx-opt-quotes",
            "docx-opt-hyphens",
            "docx-opt-whitespace",
            "docx-opt-unit-cm",
            "docx-opt-unit-circ",
            "docx-opt-greek",
            "docx-opt-supsub",
            "docx-opt-nonascii",
            "docx-opt-latex-space-block",
            "docx-opt-latex-space-inline",
            "docx-opt-nbsp-narrow",
            "camera-select",
            "camera-res-full",
            "camera-max-pixels",
            "camera-auto-process",
            "camera-auto-save",
            "camera-auto-read",
            "vision-prompt",
            "vision-mute-toggle",
            "camera-auto-vision-mode",
            "toc-pages",
            "toc-offset",
        ];

        let quickProfiles = { Standard: {} };
        let currentProfileName = "Standard";
        const INTERNAL_STORAGE_KEY =
            "DokumentZuEBuch_Internal_AutoSave_SecureKey_v1";
        const LS_KEY_NAME = "ocr_settings_auto_enc";

        function buf2base64(buffer) {
            let binary = "";
            const bytes = new Uint8Array(buffer);
            const len = bytes.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return window.btoa(binary);
        }
        function base642buf(base64) {
            const binary_string = window.atob(base64);
            const len = binary_string.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binary_string.charCodeAt(i);
            }
            return bytes.buffer;
        }
        async function deriveKey(password, salt) {
            const enc = new TextEncoder();
            const keyMaterial = await window.crypto.subtle.importKey(
                "raw",
                enc.encode(password),
                { name: "PBKDF2" },
                false,
                ["deriveKey"],
            );
            return window.crypto.subtle.deriveKey(
                {
                    name: "PBKDF2",
                    salt: salt,
                    iterations: 100000,
                    hash: "SHA-256",
                },
                keyMaterial,
                { name: "AES-GCM", length: 256 },
                false,
                ["encrypt", "decrypt"],
            );
        }
        async function encryptData(text, password) {
            const enc = new TextEncoder();
            const salt = window.crypto.getRandomValues(new Uint8Array(16));
            const iv = window.crypto.getRandomValues(new Uint8Array(12));
            const key = await deriveKey(password, salt);
            const encryptedContent = await window.crypto.subtle.encrypt(
                { name: "AES-GCM", iv: iv },
                key,
                enc.encode(text),
            );
            return {
                isEncrypted: true,
                salt: buf2base64(salt),
                iv: buf2base64(iv),
                data: buf2base64(encryptedContent),
            };
        }
        async function decryptData(encryptedObj, password) {
            try {
                const salt = base642buf(encryptedObj.salt);
                const iv = base642buf(encryptedObj.iv);
                const data = base642buf(encryptedObj.data);
                const key = await deriveKey(password, salt);
                const decryptedContent = await window.crypto.subtle.decrypt(
                    { name: "AES-GCM", iv: iv },
                    key,
                    data,
                );
                const dec = new TextDecoder();
                return dec.decode(decryptedContent);
            } catch (e) {
                throw new Error("Entschl√ºsselung fehlgeschlagen.");
            }
        }

        function requestPassword(message) {
            return new Promise((resolve) => {
                modalMessage.textContent = message;
                modalInput.value = "";
                passwordModal.style.display = "flex";
                modalInput.focus();
                const handleOk = () => {
                    cleanup();
                    resolve(modalInput.value);
                };
                const handleCancel = () => {
                    cleanup();
                    resolve(null);
                };
                const handleKeydown = (e) => {
                    if (e.key === "Enter") handleOk();
                    if (e.key === "Escape") handleCancel();
                };
                const cleanup = () => {
                    modalOkBtn.removeEventListener("click", handleOk);
                    modalCancelBtn.removeEventListener(
                        "click",
                        handleCancel,
                    );
                    modalInput.removeEventListener(
                        "keydown",
                        handleKeydown,
                    );
                    passwordModal.style.display = "none";
                };
                modalOkBtn.addEventListener("click", handleOk);
                modalCancelBtn.addEventListener("click", handleCancel);
                modalInput.addEventListener("keydown", handleKeydown);
            });
        }

        function gatherSettings() {
            const settings = {};
            settingsIds.forEach((id) => {
                const element = document.getElementById(id);
                if (element) {
                    if (element.type === "checkbox")
                        settings[id] = element.checked;
                    else settings[id] = element.value;
                }
            });
            return settings;
        }

        function applySettings(settings) {
            if (settings["pipeline-select"]) {
                pipelineSelect.value = settings["pipeline-select"];
                updateApiSettings();
            }
            for (const [id, value] of Object.entries(settings)) {
                if (id.startsWith("_") || id === "pipeline-select")
                    continue;
                const element = document.getElementById(id);
                if (element) {
                    if (element.type === "checkbox") {
                        element.checked = value;
                        element.setAttribute("aria-checked", value);
                    } else if (id === "model-name") {
                        let optionExists = false;
                        for (let i = 0; i < element.options.length; i++) {
                            if (element.options[i].value === value) {
                                optionExists = true;
                                break;
                            }
                        }
                        if (!optionExists && value !== "") {
                            const newOpt = new Option(value, value);
                            element.add(newOpt, 0);
                        }
                        element.value = value;
                    } else {
                        element.value = value;
                    }
                    element.dispatchEvent(new Event("change"));
                }
            }
        }

        function updateProfileSelect() {
            quickSettingsSelect.innerHTML = "";
            Object.keys(quickProfiles).forEach((name) => {
                const option = document.createElement("option");
                option.value = name;
                option.textContent = name;
                quickSettingsSelect.appendChild(option);
            });
            quickSettingsSelect.value = currentProfileName;
        }

        quickSettingsSelect.addEventListener("change", () => {
            const selectedName = quickSettingsSelect.value;
            if (quickProfiles[selectedName]) {
                currentProfileName = selectedName;
                applySettings(quickProfiles[selectedName]);
                logMessage(`Profil "${selectedName}" geladen.`);
            }
        });

        addProfileBtn.addEventListener("click", () => {
            const name = prompt("Name f√ºr das neue Profil:");
            if (name && name.trim() !== "") {
                quickProfiles[name.trim()] = gatherSettings();
                currentProfileName = name.trim();
                updateProfileSelect();
                logMessage(`Profil "${currentProfileName}" erstellt.`);
                saveToLocalStorage();
            }
        });

        delProfileBtn.addEventListener("click", () => {
            const selectedName = quickSettingsSelect.value;
            if (selectedName === "Standard")
                return alert("Standard kann nicht gel√∂scht werden.");
            if (confirm(`Profil "${selectedName}" l√∂schen?`)) {
                delete quickProfiles[selectedName];
                currentProfileName = "Standard";
                updateProfileSelect();
                applySettings(quickProfiles["Standard"]);
                logMessage(`Profil "${selectedName}" gel√∂scht.`);
                saveToLocalStorage();
            }
        });

        async function saveToLocalStorage() {
            if (!autoSaveLocalCheckbox.checked) return;
            if (quickProfiles[currentProfileName])
                quickProfiles[currentProfileName] = gatherSettings();

            const currentTheme =
                document.documentElement.classList.contains("light-theme")
                    ? "light"
                    : "dark";

            const dataToSave = {
                ...gatherSettings(),
                _quickProfiles: quickProfiles,
                _activeProfile: currentProfileName,
                _theme: currentTheme,
            };
            try {
                const encryptedObj = await encryptData(
                    JSON.stringify(dataToSave),
                    INTERNAL_STORAGE_KEY,
                );
                localStorage.setItem(
                    LS_KEY_NAME,
                    JSON.stringify(encryptedObj),
                );
            } catch (e) {
                console.error("Auto-Save Error:", e);
            }
        }

        async function loadFromLocalStorage() {
            const encryptedDataStr = localStorage.getItem(LS_KEY_NAME);
            quickProfiles["Standard"] = gatherSettings();

            try {
                if (encryptedDataStr) {
                    const encryptedObj = JSON.parse(encryptedDataStr);
                    const decryptedString = await decryptData(
                        encryptedObj,
                        INTERNAL_STORAGE_KEY,
                    );
                    const settings = JSON.parse(decryptedString);
                    if (settings._quickProfiles)
                        quickProfiles = settings._quickProfiles;
                    if (
                        settings._activeProfile &&
                        quickProfiles[settings._activeProfile]
                    )
                        currentProfileName = settings._activeProfile;

                    if (settings._theme) {
                        if (settings._theme === "light") {
                            document.documentElement.classList.add(
                                "light-theme",
                            );
                            updateThemeIcon(true);
                        } else {
                            document.documentElement.classList.remove(
                                "light-theme",
                            );
                            updateThemeIcon(false);
                        }
                    }

                    updateProfileSelect();
                    applySettings(settings);
                    autoSaveLocalCheckbox.checked = true;
                    autoSaveLocalCheckbox.setAttribute(
                        "aria-checked",
                        true,
                    );
                    logMessage(
                        "Einstellungen und Profile automatisch geladen.",
                    );
                } else {
                    updateProfileSelect();
                }
            } catch (e) {
                console.error("Auto-Load Error:", e);
                updateProfileSelect();
            }

            checkModelAndFocus();
        }

        function checkModelAndFocus() {
            if (!modelNameSelect.value || modelNameSelect.value === "") {
                mainSettings.open = true;
                apiSettingsDetails.open = true;
                apiKeyInput.focus();
            }
        }

        function initAutoSaveListeners() {
            autoSaveLocalCheckbox.addEventListener("change", () => {
                if (autoSaveLocalCheckbox.checked) saveToLocalStorage();
                else localStorage.removeItem(LS_KEY_NAME);
            });
            settingsIds.forEach((id) => {
                const el = document.getElementById(id);
                if (el)
                    el.addEventListener("change", () => {
                        if (quickProfiles[currentProfileName])
                            quickProfiles[currentProfileName] =
                                gatherSettings();
                        saveToLocalStorage();
                    });
            });
        }

        async function saveSettingsToFile() {
            quickProfiles[currentProfileName] = gatherSettings();
            const dataToSave = {
                ...gatherSettings(),
                _quickProfiles: quickProfiles,
                _activeProfile: currentProfileName,
            };
            const jsonString = JSON.stringify(dataToSave, null, 2);
            const password = await requestPassword(
                "Passwort f√ºr Verschl√ºsselung eingeben (leer lassen f√ºr unverschl√ºsselt):",
            );
            if (password === null) return;
            let finalOutput = jsonString;
            let isEncrypted = false;
            if (password.trim() !== "") {
                try {
                    const encryptedObj = await encryptData(
                        jsonString,
                        password,
                    );
                    finalOutput = JSON.stringify(encryptedObj, null, 2);
                    isEncrypted = true;
                } catch (e) {
                    return alert("Verschl√ºsselungsfehler: " + e.message);
                }
            }
            let defaultName = isEncrypted
                ? "ocr_einstellungen.enc.json"
                : "ocr_einstellungen.json";
            const blob = new Blob([finalOutput], {
                type: "application/json",
            });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = defaultName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            logMessage(`Einstellungen gespeichert (${defaultName}).`);
        }

        function loadSettingsFromFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = async function (e) {
                try {
                    let parsedJson = JSON.parse(e.target.result);
                    let settings = parsedJson;
                    if (parsedJson.isEncrypted) {
                        const password = await requestPassword(
                            "Datei ist verschl√ºsselt. Passwort:",
                        );
                        if (!password) return;
                        const decryptedString = await decryptData(
                            parsedJson,
                            password,
                        );
                        settings = JSON.parse(decryptedString);
                    }
                    if (settings._quickProfiles)
                        quickProfiles = settings._quickProfiles;
                    if (settings._activeProfile)
                        currentProfileName = settings._activeProfile;
                    updateProfileSelect();
                    applySettings(settings);
                    logMessage("Einstellungen geladen.");
                    saveToLocalStorage();
                } catch (err) {
                    alert("Fehler: " + err.message);
                }
                configLoader.value = "";
            };
            reader.readAsText(file);
        }

        saveSettingsBtn.addEventListener("click", saveSettingsToFile);
        loadSettingsBtn.addEventListener("click", () =>
            configLoader.click(),
        );
        configLoader.addEventListener("change", loadSettingsFromFile);

        // --- GLOBAL STATE ---
        let isProcessing = false;
        let stopRequested = false;
        let allMarkdownResults = [];
        let firstFileName = "ergebnis";
        let appInitialized = false;
        let totalStartTime = 0;

        function logMessage(message) {
            if (logEl) {
                logEl.textContent += message + "\n";
                logEl.scrollTop = logEl.scrollHeight;
            } else console.log(message);
        }

        async function sendToLLM(base64Image, retries, promptOverride) {
            const selectedPipeline = pipelineSelect.value;
            const baseUrl = baseUrlInput.value;
            const model =
                modelNameSelect.value === ""
                    ? customModelNameInput.value
                    : modelNameSelect.value;
            const apiKey = apiKeyInput.value;
            const prompt = promptOverride || promptInput.value;
            const temperature = parseFloat(temperatureInput.value);
            const repeatPenalty = parseFloat(repeatPenaltyInput.value);
            const topP = parseFloat(topPInput.value);
            const topK = parseInt(topKInput.value, 10);
            const delay = parseInt(delayInput.value, 10);

            if (!model) return "[FEHLER: KEIN MODELL]";

            let payload;
            const headers = { "Content-Type": "application/json" };
            if (apiKey) headers["Authorization"] = `Bearer ${apiKey}`;

            if (
                selectedPipeline === "ollama" ||
                selectedPipeline === "ollama-openwebui"
            ) {
                payload = {
                    model: model,
                    prompt: prompt,
                    images: [base64Image.split(",")[1]],
                    stream: false,
                    options: {
                        temperature: temperature,
                        repeat_penalty: repeatPenalty,
                        top_p: topP,
                        top_k: topK,
                    },
                };
            } else {
                // Covers 'openai' and 'openai-openwebui'
                payload = {
                    model: model,
                    messages: [
                        {
                            role: "user",
                            content: [
                                { type: "text", text: prompt },
                                {
                                    type: "image_url",
                                    image_url: { url: base64Image },
                                },
                            ],
                        },
                    ],
                    temperature: temperature,
                    presence_penalty: repeatPenalty,
                    top_p: topP,
                };
                // top_k is not standard in OpenAI API, but some providers might support it.
                // However, standard OpenAI doesn't. We'll include it if it's not 0 just in case.
                if (topK > 0) {
                    payload.top_k = topK;
                }
            }

            for (let attempt = 0; attempt <= retries; attempt++) {
                try {
                    await new Promise((resolve) =>
                        setTimeout(resolve, delay),
                    );
                    const response = await fetch(baseUrl, {
                        method: "POST",
                        headers: headers,
                        body: JSON.stringify(payload),
                    });
                    if (!response.ok)
                        throw new Error(`API ${response.status}`);
                    const data = await response.json();
                    if (data.response) return data.response;
                    if (data.choices && data.choices[0].message.content)
                        return data.choices[0].message.content;
                    throw new Error("Format?");
                } catch (error) {
                    if (attempt >= retries)
                        return `[FEHLER: ${error.message}]`;
                }
            }
        }
        // --- PREVIEW SYSTEM LOGIC (GLOBAL) ---

        async function renderPreviewItem(index) {
            if (index < 0 || index >= previewItems.length) return;

            currentPreviewIndex = index;
            // Update input field
            if (imgNavInput) imgNavInput.value = index + 1;

            const item = previewItems[index];
            let base64 = null;
            const dpi = parseInt(dpiInput.value, 10) || 150;

            try {
                if (item.type === "base64") {
                    base64 = item.data;
                } else if (item.type === "image") {
                    base64 = await getBase64FromImage(item.file);
                } else if (item.type === "pdf") {
                    base64 = await getBase64FromPdfPage(
                        item.doc,
                        item.page,
                        dpi,
                    );
                }

                if (base64) {
                    imagePreview.src = base64;
                    // Important: Update global var so manual prompts use this displayed image
                    lastProcessedImageBase64 = base64;
                } else {
                    logMessage(
                        `Fehler: Konnte Bild f√ºr Element ${index + 1} nicht generieren.`,
                    );
                }
            } catch (e) {
                logMessage(`Vorschau-Fehler: ${e.message}`);
                console.error(e);
            }
        }

        async function loadPreviewContent() {
            // Reset Preview State
            previewItems = [];
            currentPreviewIndex = 0;
            imagePreview.src = "";
            imgNavControls.style.display = "none";

            if (cameraQueue.length > 0) {
                cameraQueue.forEach((b64) =>
                    previewItems.push({ type: "base64", data: b64 }),
                );
            } else if (fileInput.files.length > 0) {
                const files = Array.from(fileInput.files);

                for (const file of files) {
                    // Check for PDF by MIME type or extension
                    const isPdf =
                        file.type === "application/pdf" ||
                        file.name.toLowerCase().endsWith(".pdf");

                    if (isPdf) {
                        try {
                            if (typeof pdfjsLib === "undefined") {
                                logMessage(
                                    "CRITICAL ERROR: PDF.js library not loaded.",
                                );
                                continue;
                            }

                            if (!pdfjsLib.GlobalWorkerOptions.workerSrc) {
                                pdfjsLib.GlobalWorkerOptions.workerSrc =
                                    "libs/pdfjs/pdf.worker.min.js";
                            }

                            const arrayBuffer = await file.arrayBuffer();
                            const uint8Array = new Uint8Array(arrayBuffer);
                            const loadingTask = pdfjsLib.getDocument({
                                data: uint8Array,
                            });
                            const pdfDoc = await loadingTask.promise;

                            // All pages to stack
                            for (let i = 1; i <= pdfDoc.numPages; i++) {
                                previewItems.push({
                                    type: "pdf",
                                    doc: pdfDoc,
                                    page: i,
                                });
                            }
                        } catch (e) {
                            logMessage(
                                `Fehler beim Laden von PDF ${file.name}: ${e.message}`,
                            );
                        }
                    } else if (file.type.startsWith("image/")) {
                        previewItems.push({ type: "image", file: file });
                    }
                }
            }

            if (previewItems.length > 0) {
                imgNavControls.style.display =
                    previewItems.length > 1 ? "flex" : "none";
                if (imgTotalCount)
                    imgTotalCount.textContent = "/ " + previewItems.length;

                await renderPreviewItem(0);
                if (fileInput.files.length > 0) {
                    logMessage(
                        `${previewItems.length} Seite(n) geladen. Bereit.`,
                    );
                }
            }
        }

        // Navigation Listeners
        imgPrevBtn.addEventListener("click", () => {
            if (currentPreviewIndex > 0)
                renderPreviewItem(currentPreviewIndex - 1);
        });
        imgNextBtn.addEventListener("click", () => {
            if (currentPreviewIndex < previewItems.length - 1)
                renderPreviewItem(currentPreviewIndex + 1);
        });

        // --- Navigation Logic Update ---

        function jumpToPage() {
            // Sicherheitscheck, falls Element nicht geladen
            if (!imgNavInput) return;

            let val = parseInt(imgNavInput.value);

            // Falls Eingabe ung√ºltig ist (leer oder Text), auf aktuelle Seite zur√ºcksetzen
            if (isNaN(val)) {
                val = currentPreviewIndex + 1;
            }

            // Grenzen pr√ºfen (nicht kleiner als 1, nicht gr√∂√üer als Anzahl Bilder)
            if (val < 1) val = 1;
            if (previewItems.length > 0 && val > previewItems.length)
                val = previewItems.length;

            // Nur neu laden, wenn sich die Seite wirklich ge√§ndert hat
            if (val - 1 !== currentPreviewIndex) {
                renderPreviewItem(val - 1);
            } else {
                // Falls wir auf der gleichen Seite bleiben, nur den Wert im Feld korrigieren
                imgNavInput.value = val;
            }
        }

        // Event Listener sicher hinzuf√ºgen
        if (imgNavInput) {
            imgNavInput.addEventListener("keydown", (e) => {
                if (e.key === "Enter") {
                    e.preventDefault(); // Verhindert Standardverhalten
                    jumpToPage(); // Seite wechseln
                    imgNavInput.blur(); // Fokus vom Feld nehmen (l√∂st 'blur' aus)
                }
            });

            // Beim Verlassen des Feldes (Klick woanders hin oder Tab)
            imgNavInput.addEventListener("blur", () => {
                // Kurze Verz√∂gerung, um Konflikte mit Enter zu vermeiden
                setTimeout(jumpToPage, 50);
            });
        }

        imgNavInput.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
                jumpToPage();
                imgNavInput.blur();
            }
        });
        imgNavInput.addEventListener("blur", jumpToPage);

        // File Input Change
        fileInput.addEventListener("change", () => {
            if (fileInput.files.length > 0) {
                cameraQueue = [];
                updateCameraFileStatus();

                // Display Filename
                const count = fileInput.files.length;
                const text =
                    count === 1
                        ? fileInput.files[0].name
                        : `${count} Dateien ausgew√§hlt`;
                fileNameDisplay.textContent = text;
                fileNameDisplay.style.display = "block";

                firstFileName =
                    fileInput.files[0].name
                        .split(".")
                        .slice(0, -1)
                        .join(".") || "download";
                logMessage(
                    `${fileInput.files.length} Datei(en) ausgew√§hlt.`,
                );
                toggleProcessingBtn.disabled = false;
                loadPreviewContent(); // Trigger immediate preview
            } else {
                fileNameDisplay.style.display = "none";
            }
        });

        // Manual Prompt ENTER Handler
        manualPromptInput.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
                e.preventDefault();
                if (isProcessing) return;
                toggleProcessingBtn.click();
            }
        });

        function formatTime(ms) {
            if (!isFinite(ms) || isNaN(ms)) return "--:--";
            const totalSeconds = Math.floor(ms / 1000);
            const m = Math.floor(totalSeconds / 60);
            const s = totalSeconds % 60;
            return `${m.toString().padStart(2, "0")}:${s.toString().padStart(2, "0")}`;
        }

        function initApp() {
            if (typeof pdfjsLib !== "undefined") {
                pdfjsLib.GlobalWorkerOptions.workerSrc =
                    "libs/pdfjs/pdf.worker.min.js";
            } else {
                return console.error(
                    "PDF.js library did not load properly",
                );
            }
            appInitialized = true;
            initTTS();

            document.getElementById("analyze-toc-btn").addEventListener("click", analyzeToc);

            toggleProcessingBtn.addEventListener("click", () => {
                if (isProcessing) {
                    stopRequested = true;
                    toggleProcessingBtn.textContent = "Stoppt...";
                    toggleProcessingBtn.disabled = true;
                } else {
                    startProcessing();
                }
            });

            downloadMdBtn.addEventListener("click", () => {
                if (appInitialized) downloadMarkdown(isProcessing);
            });
            downloadDocxBtn.addEventListener("click", () => {
                if (appInitialized) downloadDocx();
            });

            toggleRawBtn.addEventListener("click", () =>
                setPreviewMode("raw"),
            );
            toggleRenderedBtn.addEventListener("click", () =>
                setPreviewMode("rendered"),
            );

            const docxOptions = [
                docxOptUnitCm,
                docxOptUnitCirc,
                docxOptGreek,
                docxOptSupsub,
                docxOptNonAscii,
                docxOptLatexSpaceBlock,
                docxOptLatexSpaceInline,
                docxOptNbspNarrow,
                docxOptLatex,
                docxOptDollar,
                docxOptCdot,
                docxOptImages,
                docxOptDashes,
                docxOptTables,
                docxOptQuotes,
                docxOptHyphens,
                docxOptWhitespace,
            ];
            docxOptions.forEach((opt) => {
                opt.addEventListener("change", () => {
                    updateAriaChecked({ target: opt });
                    if (toggleRenderedBtn.classList.contains("active"))
                        updateTextPreview(rawPreview.value);
                });
            });

            // --- MAIN PROCESSING LOGIC ---
            async function startProcessing() {
                if (isProcessing) return;

                // Manual Prompt Check
                const manualPrompt = manualPromptInput.value.trim();
                const isManualRun = manualPrompt !== "";

                if (
                    !isManualRun &&
                    fileInput.files.length === 0 &&
                    cameraQueue.length === 0
                ) {
                    logMessage(
                        "Fehler: Bitte Dateien w√§hlen oder Foto machen.",
                    );
                    return;
                }
                if (isManualRun && !lastProcessedImageBase64) {
                    logMessage(
                        "Fehler: Kein Bild f√ºr den manuellen Prompt geladen.",
                    );
                    return;
                }

                isProcessing = true;
                stopRequested = false;

                // Reset results ONLY if full run
                if (!isManualRun) {
                    allMarkdownResults = [];
                    lastProcessedIndex = -1;
                    // Inhaltsverzeichnis Status zur√ºcksetzen
                    if (globalToc) globalToc.forEach(h => h.processed = false);
                }

                logEl.textContent = isManualRun
                    ? "F√ºhre manuellen Prompt aus...\n"
                    : "Starte Verarbeitung...\n";
                // Change Button State
                toggleProcessingBtn.innerHTML = "‚ñ† Stop";
                toggleProcessingBtn.classList.add("stop-mode");
                toggleProcessingBtn.disabled = false;
                downloadMdBtn.disabled = true;
                downloadDocxBtn.disabled = true;

                progressWrapper.style.display = "block";
                if (!isManualRun) {
                    progressFill.style.width = "0%";
                    progressText.textContent = "Initialisiere...";
                    etaText.textContent = "Berechne...";
                }

                const pageRange = parsePageRanges(pageRangeInput.value);
                const dpi = parseInt(dpiInput.value, 10);

                const processingOptions = {
                    enableNumbering: enableNumberingInput.checked,
                    startPdfPage: parseInt(startPdfPageInput.value, 10),
                    currentPageNumber: parseInt(
                        startPageNumberInput.value,
                        10,
                    ),
                    retries: parseInt(retriesInput.value, 10) || 1,
                    promptOverride: isManualRun ? manualPrompt : null,
                };

                totalStartTime = performance.now();
                let totalPagesToProcess = 0;
                let processingQueue = [];

                // Build Queue
                if (isManualRun) {
                    // Use currently visible image
                    processingQueue.push({
                        type: "reprompt",
                        data: lastProcessedImageBase64,
                    });
                    totalPagesToProcess = 1;
                    manualPromptInput.value = "";
                } else if (cameraQueue.length > 0) {
                    cameraQueue.forEach((b64) =>
                        processingQueue.push({ type: "camera", data: b64 }),
                    );
                    totalPagesToProcess = processingQueue.length;
                } else {
                    const files = Array.from(fileInput.files);
                    for (const file of files) {
                        if (file.type === "application/pdf") {
                            try {
                                const pdfData = await file.arrayBuffer();
                                const pdfDoc = await pdfjsLib.getDocument({
                                    data: pdfData,
                                }).promise;
                                const pRange =
                                    pageRange.length > 0
                                        ? pageRange.filter(
                                            (p) =>
                                                p > 0 &&
                                                p <= pdfDoc.numPages,
                                        )
                                        : Array.from(
                                            { length: pdfDoc.numPages },
                                            (_, i) => i + 1,
                                        );
                                for (const pageNum of pRange) {
                                    processingQueue.push({
                                        type: "pdf",
                                        doc: pdfDoc,
                                        page: pageNum,
                                    });
                                }
                            } catch (e) {
                                logMessage("Fehler PDF: " + e.message);
                            }
                        } else if (file.type.startsWith("image/")) {
                            processingQueue.push({
                                type: "image",
                                file: file,
                            });
                        }
                    }
                    totalPagesToProcess = processingQueue.length;
                }

                let processedCount = 0;
                try {
                    for (const item of processingQueue) {
                        if (stopRequested) break;
                        progressText.textContent = isManualRun
                            ? "Bearbeite manuellen Prompt..."
                            : `Seite ${processedCount + 1} von ${totalPagesToProcess}`;

                        let base64Provider;
                        let pageNumForNumbering =
                            processingOptions.startPdfPage;

                        if (
                            item.type === "reprompt" ||
                            item.type === "camera"
                        ) {
                            base64Provider = async () => item.data;
                        } else if (item.type === "image") {
                            base64Provider = () =>
                                getBase64FromImage(item.file);
                        } else if (item.type === "pdf") {
                            base64Provider = () =>
                                getBase64FromPdfPage(
                                    item.doc,
                                    item.page,
                                    dpi,
                                );
                            pageNumForNumbering = item.page;
                        }

                        await processPage(
                            base64Provider,
                            pageNumForNumbering,
                            processingOptions,
                            isManualRun,
                        );
                        processedCount++;
                        updateProgress(processedCount, totalPagesToProcess);
                    }
                } catch (error) {
                    logMessage(`--- FATALER FEHLER: ${error.message} ---`);
                } finally {
                    logMessage(
                        stopRequested
                            ? "--- Abgebrochen ---"
                            : "--- Fertig ---",
                    );
                    isProcessing = false;
                    toggleProcessingBtn.innerHTML = "‚ñ∂ Start";
                    toggleProcessingBtn.classList.remove("stop-mode");
                    toggleProcessingBtn.disabled = false;

                    if (allMarkdownResults.length > 0) {
                        downloadMdBtn.disabled = false;
                        downloadDocxBtn.disabled = false;
                    }

                    if (
                        !stopRequested &&
                        processedCount === totalPagesToProcess
                    ) {
                        progressFill.style.width = "100%";
                        progressText.textContent = "Fertig!";

                        if (!isManualRun && allMarkdownResults.length > 0) {
                            if (shouldAutoSave) downloadDocx();
                            if (shouldAutoRead) {
                                const ttsBtn =
                                    document.getElementById("tts-btn");
                                if (
                                    ttsBtn &&
                                    !ttsBtn.classList.contains("speaking")
                                )
                                    ttsBtn.click();
                            }
                        }
                    }

                    if (wasAutoProcessed) {
                        cameraQueue = [];
                        updateCameraFileStatus();
                        shouldAutoSave = false;
                        shouldAutoRead = false;
                        wasAutoProcessed = false;
                    }
                }
            }

            function updateProgress(processed, total) {
                if (total === 0) return;
                const percentage = Math.round((processed / total) * 100);
                progressFill.style.width = `${percentage}%`;
                const now = performance.now();
                const etaMs =
                    ((now - totalStartTime) / processed) *
                    (total - processed);
                etaText.textContent = `Verbleibend: ~${formatTime(etaMs)}`;
            }

            async function processPage(
                base64Provider,
                pageNum,
                options,
                isManualRun,
            ) {
                logMessage(`Verarbeite Seite ${pageNum}...`);
                const startTime = performance.now();
                const base64Image = await base64Provider();
                // Update global last image for context
                lastProcessedImageBase64 = base64Image;

                // --- ToC Kontext hinzuf√ºgen ---
                let extraPrompt = "";
                if (globalToc && globalToc.length > 0) {
                    // Nur √úberschriften nehmen, die f√ºr diese Seite gedacht sind UND noch nicht verarbeitet wurden
                    const pageHeadings = globalToc.filter(h => h.seite === pageNum && !h.processed);
                    if (pageHeadings.length > 0) {
                        extraPrompt = "\n\nHINWEIS ZUR STRUKTUR (FALLS VORHANDEN):\n" +
                            "Falls auf dieser Seite die folgenden Kapitel/√úberschriften GEDRUCKT sind, formatiere sie bitte zwingend mit der angegebenen Markdown-Hierarchie. " +
                            "Falls eine dieser √úberschriften NICHT auf dem Bild zu sehen ist, f√ºge sie NICHT hinzu (halluziniere sie nicht). " +
                            "Ignoriere auch Kopfzeilen (Running Headers), die den Titel nur wiederholen, falls sie nicht die eigentliche √úberschrift der Seite sind:\n" +
                            pageHeadings.map(h => `${"#".repeat(Math.max(1, h.ebene))} ${h.titel}`).join("\n");
                    }
                }

                // --- LOG PIXEL COUNT & DIMENSIONS (NEW) ---
                await new Promise((resolve) => {
                    const i = new Image();
                    i.onload = () => {
                        logMessage(
                            `Bild-Dimensionen: ${i.width}x${i.height} (${i.width * i.height} Pixel)`,
                        );
                        resolve();
                    };
                    i.onerror = resolve; // Don't block if fails
                    i.src = base64Image;
                });
                // ------------------------------------------

                const markdown = await sendToLLM(
                    base64Image,
                    options.retries,
                    options.promptOverride ? options.promptOverride + extraPrompt : promptInput.value + extraPrompt,
                );
                const processingTime = performance.now() - startTime;

                let formattedMarkdown = markdown;

                // --- Automatische √úberschriften-Reparatur ---
                if (!isManualRun && globalToc && globalToc.length > 0) {
                    // Wir pr√ºfen ALLE noch nicht verarbeiteten √úberschriften, 
                    // ob sie auf dieser Seite aufgetaucht sind (entweder korrekt oder reparaturbed√ºrftig)
                    globalToc.forEach(h => {
                        if (h.processed) return;

                        const escapedTitle = h.titel.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                        const headerPrefix = "#".repeat(Math.max(1, h.ebene));
                        const correctHeader = `${headerPrefix} ${h.titel}`;

                        // 1. Pr√ºfen, ob sie bereits KORREKT da ist (z.B. vom LLM richtig gemacht)
                        const exactHeaderRegex = new RegExp(`(^|\\n)${headerPrefix}\\s*${escapedTitle}\\s*(\\n|$)`, 'gi');
                        if (exactHeaderRegex.test(formattedMarkdown)) {
                            h.processed = true;
                            // logMessage(`Info: √úberschrift "${h.titel}" korrekt erkannt.`);
                            return;
                        }

                        // 2. Suche nach fettgeschriebenen Varianten: **Titel** -> ## Titel
                        // Wir pr√ºfen hier NUR auf der Zielseite, um Kopfzeilen-Upgrades zu vermeiden.
                        if (h.seite === pageNum) {
                            const boldRegex = new RegExp(`\\*\\*\\s*${escapedTitle}\\s*\\*\\*`, 'gi');
                            if (boldRegex.test(formattedMarkdown)) {
                                formattedMarkdown = formattedMarkdown.replace(boldRegex, correctHeader);
                                h.processed = true;
                                logMessage(`Fix: √úberschrift "${h.titel}" von Fett zu H${h.ebene} korrigiert.`);
                                return;
                            }
                        }

                        // 3. Suche nach Titeln, die als eigene Zeile stehen, aber kein Header sind
                        // Wir pr√ºfen hier NUR, wenn die Seite laut ToC auch wirklich dran ist, 
                        // um "Running Header" Upgrades auf falschen Seiten zu vermeiden.
                        if (h.seite === pageNum) {
                            const plainLineRegex = new RegExp(`(^|\\n)(?!#)\\s*${escapedTitle}\\s*(\\n|$)`, 'gi');
                            if (plainLineRegex.test(formattedMarkdown)) {
                                formattedMarkdown = formattedMarkdown.replace(plainLineRegex, `$1${correctHeader}$2`);
                                h.processed = true;
                                logMessage(`Fix: Text "${h.titel}" zu H${h.ebene} hochgestuft.`);
                            }
                        }
                    });
                }

                if (!isManualRun && options.enableNumbering) {
                    const prefix =
                        pageNum >= options.startPdfPage
                            ? `((${options.currentPageNumber}))\n\n`
                            : `(( ))\n\n`;
                    formattedMarkdown = prefix + markdown;
                    if (pageNum >= options.startPdfPage)
                        options.currentPageNumber++;
                }

                if (isManualRun) {
                    if (allMarkdownResults.length > 0) {
                        allMarkdownResults.push(
                            `\n\n--- Manueller Nachtrag ---\n${formattedMarkdown}`,
                        );
                    } else {
                        allMarkdownResults.push(formattedMarkdown);
                    }
                } else {
                    allMarkdownResults.push(formattedMarkdown);
                }

                // Show image only after processing if full run
                if (!isManualRun) {
                    updateImagePreview(base64Image);
                }

                updateTextPreview(formattedMarkdown);
                downloadMdBtn.disabled = false;
                downloadDocxBtn.disabled = false;
                logMessage(
                    `Dauer: ${(processingTime / 1000).toFixed(1)} s.`,
                );
            }

            async function handleVisionChat() {
                const text = visionUserInput.value.trim();
                if (!text || !currentVisionBase64) return;

                // iOS Unlock
                unlockTTS();

                // UI Updates
                const oldContent = visionResponseArea.textContent;
                visionResponseArea.innerHTML =
                    oldContent +
                    `\n\nDu: ${text}\n\n<span class="vision-loading">KI: Denkt nach...</span>`;
                visionResponseArea.scrollTop =
                    visionResponseArea.scrollHeight;

                visionUserInput.value = "";
                visionUserInput.disabled = true;
                visionSendBtn.disabled = true;

                try {
                    // Hier nutzen wir den User-Text als Prompt, schicken das Bild aber erneut mit
                    // WICHTIG: Das System-Prompt wird hier durch die User-Frage √ºberschrieben/erg√§nzt,
                    // je nachdem wie sendToLLM implementiert ist.
                    // F√ºr Chat-Verlauf m√ºssten wir eigentlich die History senden.
                    // Vereinfachung: Wir senden Bild + Frage. Das Modell sieht das Bild "neu" mit der Frage.

                    const response = await sendToLLM(
                        currentVisionBase64,
                        0,
                        text,
                    );

                    // "Loading..." entfernen und Text anh√§ngen
                    visionResponseArea.innerHTML =
                        oldContent + `\n\nDu: ${text}\n\nKI: ${response}`;
                    visionResponseArea.scrollTop =
                        visionResponseArea.scrollHeight;

                    // Nur vorlesen, wenn nicht stumm geschaltet
                    if (!visionMuteToggle.checked) {
                        speakText(response);
                    }
                } catch (e) {
                    visionResponseArea.textContent +=
                        "\n[Fehler bei der Antwort]";
                } finally {
                    visionUserInput.disabled = false;
                    visionSendBtn.disabled = false;
                    visionUserInput.focus();
                }
            }

            visionSendBtn.addEventListener("click", handleVisionChat);
            visionUserInput.addEventListener("keydown", (e) => {
                if (e.key === "Enter") handleVisionChat();
            });

            function updateImagePreview(base64Image) {
                imagePreview.src = base64Image;
            }

            function getCleanedMarkdown(markdown) {
                let cleaned = markdown;

                // --- 1. Einheiten (\text, \mathrm) bereinigen [PRIORIT√ÑT HOCH] ---
                // Wir suchen nach \text{...} oder \mathrm{...} und ersetzen es durch den Inhalt.
                // Das Muster ([^{}]+?) f√§ngt ALLES innerhalb der Klammern, egal ob Leerzeichen oder Buchstaben.
                if (docxOptUnitCm.checked) {
                    cleaned = cleaned.replace(
                        /\\(?:text|mathrm|textnormal)\s*\{\s*([^{}]+?)\s*\}/g,
                        "$1",
                    );
                }

                // --- 2. Zirkumflex (^) zu Grad (¬∞) ---
                if (docxOptUnitCirc.checked)
                    cleaned = cleaned.replace(/\^circ/g, "¬∞");

                // --- 3a. Leerzeichen in $$...$$ entfernen ---
                if (docxOptLatexSpaceBlock.checked) {
                    cleaned = cleaned.replace(
                        /\$\$([\s\S]*?)\$\$/g,
                        (match, content) => {
                            // Entfernt alle Leerzeichen im Block
                            return (
                                "$$" + content.replace(/\s+/g, "") + "$$"
                            );
                        },
                    );
                }

                // --- 3b. Leerzeichen in $...$ entfernen ---
                if (docxOptLatexSpaceInline.checked) {
                    cleaned = cleaned.replace(
                        /(\$)([^$\n]+?)(\$)/g,
                        (match, open, content, close) => {
                            // Entfernt alle Leerzeichen im Inline-Element
                            return (
                                open + content.replace(/\s+/g, "") + close
                            );
                        },
                    );
                }

                // -- 4. GREEK TO LATEX CONVERSION --
                if (docxOptGreek.checked) {
                    const greekToLatex = {
                        Œ±: "\\alpha",
                        Œ≤: "\\beta",
                        Œ≥: "\\gamma",
                        Œ¥: "\\delta",
                        Œµ: "\\epsilon",
                        œµ: "\\varepsilon",
                        Œ∂: "\\zeta",
                        Œ∑: "\\eta",
                        Œ∏: "\\theta",
                        œë: "\\vartheta",
                        Œπ: "\\iota",
                        Œ∫: "\\kappa",
                        Œª: "\\lambda",
                        Œº: "\\mu",
                        ŒΩ: "\\nu",
                        Œæ: "\\xi",
                        Œø: "o",
                        œÄ: "\\pi",
                        œÅ: "\\rho",
                        œÉ: "\\sigma",
                        œÇ: "\\varsigma",
                        œÑ: "\\tau",
                        œÖ: "\\upsilon",
                        œÜ: "\\phi",
                        œï: "\\varphi",
                        œá: "\\chi",
                        œà: "\\psi",
                        œâ: "\\omega",
                        Œë: "A",
                        Œí: "B",
                        Œì: "\\Gamma",
                        Œî: "\\Delta",
                        Œï: "E",
                        Œñ: "Z",
                        Œó: "H",
                        Œò: "\\Theta",
                        Œô: "I",
                        Œö: "K",
                        Œõ: "\\Lambda",
                        Œú: "M",
                        Œù: "N",
                        Œû: "\\Xi",
                        Œü: "O",
                        Œ†: "\\Pi",
                        Œ°: "P",
                        Œ£: "\\Sigma",
                        Œ§: "T",
                        Œ•: "\\Upsilon",
                        Œ¶: "\\Phi",
                        Œß: "X",
                        Œ®: "\\Psi",
                        Œ©: "\\Omega",
                    };
                    cleaned = cleaned.replace(/[Œ±-œâŒë-Œ©œµœëœïœÇ]/g, (match) => {
                        return (greekToLatex[match] || match) + " ";
                    });
                }

                // -- 5. SUPERSCRIPT / SUBSCRIPT --
                if (docxOptSupsub.checked) {
                    const supMap = {
                        "‚Å∞": "0",
                        "¬π": "1",
                        "¬≤": "2",
                        "¬≥": "3",
                        "‚Å¥": "4",
                        "‚Åµ": "5",
                        "‚Å∂": "6",
                        "‚Å∑": "7",
                        "‚Å∏": "8",
                        "‚Åπ": "9",
                    };
                    const subMap = {
                        "‚ÇÄ": "0",
                        "‚ÇÅ": "1",
                        "‚ÇÇ": "2",
                        "‚ÇÉ": "3",
                        "‚ÇÑ": "4",
                        "‚ÇÖ": "5",
                        "‚ÇÜ": "6",
                        "‚Çá": "7",
                        "‚Çà": "8",
                        "‚Çâ": "9",
                    };
                    cleaned = cleaned.replace(
                        /[‚Å∞¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ]/g,
                        (m) => "^" + supMap[m],
                    );
                    cleaned = cleaned.replace(
                        /[‚ÇÄ‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ‚ÇÖ‚ÇÜ‚Çá‚Çà‚Çâ]/g,
                        (m) => "_" + subMap[m],
                    );
                }

                // -- 6. NON-ASCII TO LATEX --
                if (docxOptNonAscii.checked) {
                    const charMap = {
                        "√ó": "\\times ",
                        "√∑": "\\div ",
                        "¬±": "\\pm ",
                        "‚àì": "\\mp ",
                        "‚â§": "\\leq ",
                        "‚â•": "\\geq ",
                        "‚â†": "\\neq ",
                        "‚âà": "\\approx ",
                        "‚àû": "\\infty ",
                        "‚Ä¢": "\\cdot ",
                        "‚Üí": "\\to ",
                        "‚Üî": "\\leftrightarrow ",
                        "‚áê": "\\Leftarrow ",
                        "‚áí": "\\Rightarrow ",
                        "‚áî": "\\Leftrightarrow ",
                        "‚àà": "\\in ",
                        "‚àâ": "\\notin ",
                        "‚äÇ": "\\subset ",
                        "‚äÉ": "\\supset ",
                        "‚à™": "\\cup ",
                        "‚à©": "\\cap ",
                        "‚àÄ": "\\forall ",
                        "‚àÉ": "\\exists ",
                        "‚àá": "\\nabla ",
                        "‚àÇ": "\\partial ",
                        "‚àë": "\\sum ",
                        "‚àè": "\\prod ",
                        "‚à´": "\\int ",
                    };
                    const keys = Object.keys(charMap)
                        .join("")
                        .replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
                    const re = new RegExp(`[${keys}]`, "g");
                    cleaned = cleaned.replace(re, (m) => charMap[m]);
                }

                // -- Standard Bereinigungen --
                if (docxOptNbspNarrow.checked)
                    cleaned = cleaned.replace(/\u00A0/g, "\u202F");

                if (docxOptQuotes.checked)
                    cleaned = cleaned
                        .replace(/[‚Äú‚Äû‚Äù¬´¬ª]/g, '"')
                        .replace(/[‚Äò‚Äö‚Äô‚Äπ‚Ä∫]/g, "'");

                if (docxOptHyphens.checked)
                    cleaned = cleaned.replace(/[‚Äî‚Äì]/g, "-");

                if (docxOptWhitespace.checked) {
                    const regex = docxOptNbspNarrow.checked
                        ? /[\u1680\u180E\u2000-\u200B\u205F\u3000\uFEFF]/g
                        : /[\u1680\u180E\u2000-\u200B\u202F\u205F\u3000\uFEFF]/g;
                    cleaned = cleaned.replace(regex, " ");
                    if (!docxOptNbspNarrow.checked)
                        cleaned = cleaned.replace(/\u00A0/g, " ");
                }

                if (docxOptLatex.checked)
                    cleaned = cleaned.replace(
                        /\$\$([\s\S]*?)\$\$/g,
                        "&lt;L&gt;$1&lt;/L&gt;",
                    );

                if (docxOptDollar.checked)
                    cleaned = cleaned.replace(/\$/g, "");

                if (docxOptCdot.checked)
                    cleaned = cleaned.replace(/\\cdot/g, "*");

                if (docxOptImages.checked)
                    cleaned = cleaned
                        .replace(/\(\(Bild\)\)/g, "&lt;Bild&gt;")
                        .replace(/\(\(\/Bild\)\)/g, "&lt;/Bild&gt;");

                if (docxOptDashes.checked)
                    cleaned = cleaned
                        .split("\n")
                        .filter((line) => !/^---\s*$/.test(line))
                        .join("\n");

                return cleaned;
            }
            function updateTextPreview(markdown) {
                rawPreview.value = markdown;
                let textToRender = getCleanedMarkdown(markdown);
                try {
                    let html = marked.parse(textToRender);
                    if (docxOptTables.checked)
                        html = html
                            .replace(
                                /<table/g,
                                '<p style="color:blue;">&lt;Tabelle&gt;</p><table',
                            )
                            .replace(
                                /<\/table>/g,
                                '</table><p style="color:blue;">&lt;/Tabelle&gt;</p>',
                            );
                    renderedPreview.innerHTML = html;
                    if (typeof renderMathInElement !== "undefined")
                        renderMathInElement(renderedPreview, {
                            delimiters: [
                                { left: "$$", right: "$$", display: true },
                                { left: "$", right: "$", display: false },
                            ],
                            throwOnError: false,
                        });
                } catch (e) {
                    renderedPreview.innerHTML = `<p>Error</p>`;
                }
            }

            function setPreviewMode(mode) {
                const isRaw = mode === "raw";
                rawPreview.style.display = isRaw ? "block" : "none";
                renderedPreview.style.display = isRaw ? "none" : "block";
                toggleRawBtn.classList.toggle("active", isRaw);
                toggleRawBtn.setAttribute("aria-pressed", isRaw);
                toggleRenderedBtn.classList.toggle("active", !isRaw);
                toggleRenderedBtn.setAttribute("aria-pressed", !isRaw);
                if (!isRaw) updateTextPreview(rawPreview.value);
            }

            async function analyzeToc() {
                const tocInput = document.getElementById("toc-pages").value;
                const tocStatus = document.getElementById("toc-status");
                if (!tocInput) {
                    alert("Bitte ToC-Seiten angeben.");
                    return;
                }

                if (fileInput.files.length === 0) {
                    alert("Bitte zuerst ein PDF laden.");
                    return;
                }

                const pages = parsePageRanges(tocInput);
                const dpi = parseInt(dpiInput.value, 10) || 150;
                const tocOffset = parseInt(document.getElementById("toc-offset").value) || 0;
                const btn = document.getElementById("analyze-toc-btn");

                btn.disabled = true;
                btn.textContent = "Analysiere...";
                tocStatus.textContent = "Lade Seiten...";
                globalToc = [];

                try {
                    const file = fileInput.files[0];
                    const arrayBuffer = await file.arrayBuffer();
                    const pdfDoc = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;

                    for (const pageNum of pages) {
                        if (pageNum < 1 || pageNum > pdfDoc.numPages) continue;
                        tocStatus.textContent = `VLM analysiert Seite ${pageNum}...`;

                        const base64 = await getBase64FromPdfPage(pdfDoc, pageNum, dpi);
                        const prompt = "Extrahiere das Inhaltsverzeichnis dieser Seite. Gib das Ergebnis ausschlie√ülich als JSON-Array zur√ºck. " +
                            "Jedes Element muss 'titel' (String), 'ebene' (Zahl, 1 f√ºr h1, 2 f√ºr h2 etc.) und 'buchseite' (Zahl der gedruckten Seitenzahl im Buch) enthalten. " +
                            "Beispiel: [{\"titel\": \"Einleitung\", \"ebene\": 1, \"buchseite\": 10}]. " +
                            "Antworte NUR mit dem JSON-Array, kein Markdown, kein Text drumherum.";

                        const result = await sendToLLM(base64, 1, prompt);

                        // Robuste JSON-Extraktion f√ºr jede Seite einzeln
                        const jsonMatch = result.match(/\[\s*\{[\s\S]*\}\s*\]/);
                        if (jsonMatch) {
                            try {
                                const pageToc = JSON.parse(jsonMatch[0]);
                                if (Array.isArray(pageToc)) {
                                    // Offset anwenden: Buchseite -> PDF Seite
                                    const shiftedToc = pageToc.map(item => ({
                                        ...item,
                                        seite: (parseInt(item.buchseite) || 0) + tocOffset
                                    }));
                                    globalToc = globalToc.concat(shiftedToc);
                                }
                            } catch (parseErr) {
                                logMessage(`Warnung: Konnte JSON von Seite ${pageNum} nicht parsen.`);
                            }
                        }
                    }

                    if (globalToc.length > 0) {
                        logMessage(`ToC erfolgreich analysiert: ${globalToc.length} Eintr√§ge gefunden.`);
                        tocStatus.textContent = `${globalToc.length} Eintr√§ge geladen.`;
                    } else {
                        throw new Error("Konnte keine g√ºltigen Eintr√§ge im Inhaltsverzeichnis finden.");
                    }
                } catch (e) {
                    logMessage(`ToC-Analyse Fehler: ${e.message}`);
                    tocStatus.textContent = "Analyse fehlgeschlagen.";
                } finally {
                    btn.disabled = false;
                    btn.textContent = "ToC analysieren";
                }
            }

            function parsePageRanges(input) {
                if (!input.trim()) return [];
                const ranges = new Set();
                input.split(",").forEach((part) => {
                    if (part.includes("-")) {
                        const [start, end] = part
                            .split("-")
                            .map((num) => parseInt(num.trim(), 10));
                        for (let i = start; i <= end; i++) ranges.add(i);
                    } else {
                        ranges.add(parseInt(part.trim(), 10));
                    }
                });
                return Array.from(ranges)
                    .filter((n) => !isNaN(n))
                    .sort((a, b) => a - b);
            }
            function downloadMarkdown(isIntermediate) {
                if (allMarkdownResults.length === 0) return;
                const fullMarkdown = allMarkdownResults.join("\n\n\n");
                const blob = new Blob([fullMarkdown], {
                    type: "text/markdown;charset=utf-8",
                });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = `${firstFileName}${isIntermediate ? "_zwischenstand" : ""}.md`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
            function downloadDocx() {
                if (allMarkdownResults.length === 0) return;
                const fullMarkdown = allMarkdownResults
                    .map((md) => getCleanedMarkdown(md))
                    .join("\n\n\n");
                let contentHtml = marked.parse(fullMarkdown);
                if (docxOptTables.checked)
                    contentHtml = contentHtml
                        .replace(/<table/g, "<p>&lt;Tabelle&gt;</p><table")
                        .replace(
                            /<\/table>/g,
                            "</table><p>&lt;/Tabelle&gt;</p>",
                        );
                const completeHtml = `<!DOCTYPE html><html xmlns:o='urn:schemas-microsoft-com:office:office' xmlns:w='urn:schemas-microsoft-com:office:word'><head><meta charset="utf-8"><title>Export</title><style>body{font-family:'Calibri','Arial';}</style></head><body>${contentHtml}</body></html>`;
                try {
                    const converted = htmlDocx.asBlob(completeHtml);
                    const url = URL.createObjectURL(converted);
                    const a = document.createElement("a");
                    a.href = url;
                    a.download = `${firstFileName}.docx`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    logMessage(`DOCX gespeichert.`);
                } catch (e) {
                    logMessage("Fehler Export: " + e.message);
                }
            }

            updateApiSettings();
            numberingOptions.style.display = enableNumberingInput.checked
                ? "flex"
                : "none";
            setPreviewMode("raw");
            toggleProcessingBtn.disabled = true;
            initAutoSaveListeners();
            loadFromLocalStorage();
            cameraPixelGroup.style.display = cameraResFull.checked
                ? "none"
                : "flex";
        }

        let initAppCalled = false;
        function tryInitApp() {
            if (typeof pdfjsLib !== "undefined" && !initAppCalled) {
                initAppCalled = true;
                initApp();
                return true;
            }
            return false;
        }
        initTheme();
        if (!tryInitApp()) {
            const checkPdfJsInterval = setInterval(() => {
                if (tryInitApp()) clearInterval(checkPdfJsInterval);
            }, 50);
            setTimeout(() => {
                if (!initAppCalled) {
                    clearInterval(checkPdfJsInterval);
                    initAppCalled = true;
                    initApp();
                }
            }, 5000);
        }
        customModelNameInput.style.display =
            modelNameSelect.value === "" ? "block" : "none";
    </script>
</body>

</html>